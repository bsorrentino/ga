<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Ga!</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Ga!</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Ga!</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><img src="/tutorials/screenshots/logoAndIllustration.png" alt="Ga"></p>
				<h1 id="ga">Ga</h1>
				<p><em>&quot;Ga!&quot;</em>
				<em>- A baby&#39;s exclamation of surprise.</em></p>
				<p><em>Ga</em> is a tiny, cute and friendly system for making HTML5 games or any other
					kind interactive media. You can use it to make any kind of 2D action
				game you can imagine, with unbelievably tiny file sizes (under 6.5k!)</p>
				<p>Take a look at the feature list and the <code>examples</code> folder to get
					started. Keep scrolling, and you&#39;ll find a complete beginner&#39;s
					tutorial ahead. If you&#39;ve never made a game before, the tutorials are
				the best place to start.</p>
				<h3 id="table-of-contents-">Table of contents:</h3>
				<ol>
					<li><a href="#features">Features</a></li>
					<li><a href="#plugins">The Plugins</a></li>
					<li><a href="#comingsoon">Coming soon...</a></li>
					<li><a href="#philosophy">Ga&#39;s philosophy and technical constraints</a></li>
					<li><a href="#minifying">Minifying, crushing and compressing</a></li>
					<li><a href="#contibutions">Contributions and Licencing</a></li>
					<li><a href="#hexi">Hexi</a></li>
					<li><a href="#tutorials">Tutorials</a><ol>
							<li><a href="#treasure">Treasure Hunter</a><ol>
									<li><a href="#settingup">Setting up the HTML container page</a></li>
									<li><a href="#initializing">Initializing the Ga engine</a></li>
									<li><a href="#defineglobals">Define your &quot;global&quot; variables</a></li>
									<li><a href="#setupfunction">Initialize your game with a setup function</a></li>
									<li><a href="#customizing">Customizing the canvas</a></li>
									<li><a href="#creatingsound">Creating the <code>chimes</code> sound object</a></li>
									<li><a href="#gamescenes">Creating game scenes</a></li>
									<li><a href="#makingsprites">Making sprites</a></li>
									<li><a href="#positioningsprites">Positioning sprites</a></li>
									<li><a href="#dynamicproperties">Assigning dynamic properties</a></li>
									<li><a href="#enemysprites">Creating the enemy sprites</a></li>
									<li><a href="#healthbar">The health bar</a></li>
									<li><a href="#gameoverscene">The game over scene</a></li>
									<li><a href="#keyboard">Keyboard interactivity</a></li>
									<li><a href="#gamestate">Setting the game state</a></li>
									<li><a href="#gamelogic">Game logic with the play function loop</a></li>
									<li><a href="#movingplayer">Moving the player sprite</a></li>
									<li><a href="#boundries">Containing sprites inside the screen boundaries</a></li>
									<li><a href="#collisionenemy">Collision with the enemies</a><ol>
											<li><a href="#collisiontreasure">Collision with the treasure</a></li>
										</ol>
									</li>
									<li><a href="#endinggame1">Ending the game</a></li>
									<li><a href="#usingimages">Using images</a></li>
									<li><a href="#individualimages">Individual images</a><ol>
											<li><a href="#loadingimagefile">Loading image files</a></li>
											<li><a href="#makingsprites">Making sprites with images</a></li>
											<li><a href="#finetuning">Fine-tuning the containment area</a></li>
										</ol>
									</li>
									<li><a href="#textureatlas">Using a texture atlas</a></li>
									<li><a href="#preparingimages">Preparing the images</a></li>
									<li><a href="#loadingatlas">loading the texture atlas</a></li>
								</ol>
							</li>
							<li><a href="#alienarmada">Alien Armada</a><ol>
									<li><a href="#customfonts">Load and use a custom font</a></li>
									<li><a href="#scalebrowser">Scale and center the game in the browser</a></li>
									<li><a href="#progressbar">A loading progress bar</a></li>
									<li><a href="#shootingbullets">Shooting bullets</a></li>
									<li><a href="#spritestates">Sprite states</a></li>
									<li><a href="#randomaliens">Generating random aliens</a></li>
									<li><a href="#timingaliens">Timing the aliens</a></li>
									<li><a href="#randomposition">The aliens&#39; random start positions</a></li>
									<li><a href="#movingaliens">Moving the aliens</a></li>
									<li><a href="#explodealiens">Making the aliens explode</a></li>
									<li><a href="#displayingscore">Displaying the score</a></li>
									<li><a href="#endinggame2">Ending and resetting the game</a></li>
								</ol>
							</li>
							<li><a href="#flappyfairy">Flappy Fairy!</a><ol>
									<li><a href="#launchagameinfullscreenmode">Launch a game in fullscreen mode</a></li>
									<li><a href="#makeabutton">Make a button</a></li>
									<li><a href="#makingthefairyfly">Making the fairy fly</a></li>
									<li><a href="#makeascrollingbackground">Make a scrolling background</a></li>
									<li><a href="#thefairydustexplosions">The fairy dust explosions</a></li>
									<li><a href="#useaparticleemitter">Use a particle emitter</a></li>
									<li><a href="#creatingandmovingthepillars">Creating and moving the pillars</a></li>
								</ol>
							</li>
						</ol>
					</li>
					<li><a href="#aguidetotheexamples">A Guide to the examples</a></li>
				</ol>
				<p><a id='features'></a></p>
				<h2 id="features">Features</h2>
				<p>Here&#39;s Ga&#39;s core feature list:</p>
				<ul>
					<li>All the most important sprites you need: rectangles, circles, lines,
						text, image sprites and animated &quot;MovieClip&quot; style sprites. You can make any of these
						sprites with one only line of code. You can also create your own custom sprite
					types.</li>
					<li>A complete scene graph with nested child-parent hierarchies (including
						a <code>stage</code>, and <code>addChild</code>/<code>removeChild</code> methods), local and global
					coordinates, depth layers, and rotation pivots.</li>
					<li><code>group</code> sprites together to make game scenes. </li>
					<li>A game loop with a user-definable <code>fps</code> and fully customizable and
						drop-dead-simple game state manager. <code>pause</code> and <code>resume</code> the game
					loop at any time.</li>
					<li>Tileset (spritesheet) support using <code>frame</code> and <code>filmstrip</code> methods to make
					sprites using tileset frames.</li>
					<li>Built-in texture atlas support for the popular Texture Packer
					format. Use a sprite&#39;s <code>setTexture</code> method if you want to change a sprite&#39;s image source while the game is running </li>
					<li>A keyframe animation and state manager for sprites. Use <code>show</code> to
						display a sprite&#39;s image state. Use <code>play</code> or <code>playSequence</code> to play
						a sequence of frames (in a <code>loop</code> if you want to). Use
						<code>show</code> to display a specific frame number. Use <code>fps</code> to set the
						frame rate for sprite animations which is independent from the game&#39;s
					frame rate.</li>
					<li>Interactive <code>button</code> sprites with <code>up</code>, <code>over</code> and <code>down</code> states.</li>
					<li>Any sprite can be set as <code>interactive</code> to receive mouse and touch
						actions.
						Intuitive <code>press</code>, <code>release</code>, <code>over</code>, <code>out</code> and <code>tap</code> methods for buttons and interactive
					sprites.</li>
					<li>Easy-to-use keyboard key bindings. The arrow and space keys are
						built-in, and you can easily define your own with the <code>keyboard</code>
					method.</li>
					<li>A built-in universal <code>pointer</code> that works with both the mouse and
						touch. Assign your own custom <code>press</code>, <code>release</code> and <code>tap</code> methods
						or use any of the pointer&#39;s built-in properties: <code>isUp</code>, <code>isDown</code>,
					<code>tapped</code>, <code>x</code> and <code>y</code>. Define as many pointers as you need for multi-touch.</li>
					<li>Conveniently position sprites relative to other sprites using
					<code>putTop</code>, <code>putRight</code>, <code>putBottom</code>, <code>putLeft</code> and <code>putCenter</code>.</li>
					<li>A universal asset loader to pre-load images, fonts, sounds and JSON
						data files. All popular file formats are supported. You can load new assets into the game at
					any time.</li>
					<li>An optional <code>load</code> state that lets you run actions while assets are
					loading. You can use the <code>load</code> state to add a loading progress bar.</li>
					<li>A fast and focused canvas-based rendering engine.</li>
					<li>A sophisticated game loop using a fixed timestep with variable rendering
						and sprite interpolation. That means you get butter-smooth sprite animations
					at any framerate.</li>
					<li>A <code>plugins.js</code> file full of extra tools. </li>
					<li>A compact and powerful &quot;Haiku&quot; style API that&#39;s centered on shallow,
					composable components. Get more done writing less code.</li>
					<li>Ga is totally hackable. Overwrite any of its default methods or objects
					with your own at compile or run time.</li>
					<li>Yes, Ga is mobile friendly!</li>
					<li>Yes, the core <code>ga.js</code> engine is less than 6.5k minified and zipped!
						That makes Ga the world&#39;s smallest, most light-weight full featured game engine.
						It&#39;s all you need to start making any any 2D action, puzzle or
					strategy game. </li>
				</ul>
				<p>And the coolest part? If you were alone on a desert island with only
					a solar powered laptop, an unlimited supply of
					coconuts, and a copy of <code>ga.js</code> you could recreate the entire history of 2D video games,
					from SpaceWar! to Flappy Bird. And all of it would fit on a 3.5 inch
				floppy disk.</p>
				<p><a id='plugins'></a></p>
				<h3 id="the-plugins">The plugins</h3>
				<p>But there&#39;s more! Ga comes with a <code>plugins.js</code> file that includes a
					huge number of useful tools for making games. You can use as many or
					as few of these tools as you want to. Here are some of the goodies
				you&#39;ll find in <code>plugins.js</code>:</p>
				<ul>
					<li>Import and play sounds using a built-in WebAudio API sound manager.
						Control sounds with <code>play</code>, <code>pause</code>, <code>stop</code>, <code>restart</code>,
					<code>playFrom</code>, <code>fadeIn</code> and <code>fadeOut</code> methods. Change a sound&#39;s <code>volume</code> and <code>pan</code>.</li>
					<li>Generate your own custom sound effects from pure code with
					the versatile <code>soundEffect</code> method.</li>
					<li>Shake sprites or the screen with <code>shake</code>.</li>
					<li>Tween functions for sprite and scene transitions: <code>slide</code>,
						<code>fadeIn</code>, <code>fadeOut</code>, <code>pulse</code>, <code>breathe</code>, <code>wobble</code>, <code>strobe</code> and
						some useful low-level tweening methods to help you create your own
					custom tweens.</li>
					<li>Make a sprite follow a connected series of waypoints with <code>walkPath</code>
					and <code>walkCurve</code>. </li>
					<li>A handful of useful convenience functions: <code>followEase</code>,
						<code>followConstant</code>,
						<code>angle</code>, <code>distance</code>, <code>rotateAroundSprite</code>, <code>rotateAroundPoint</code>, <code>wait</code>,
					<code>randomInt</code>, <code>randomFloat</code>, <code>contain</code> and <code>outsideBounds</code>.</li>
					<li>A fast, universal <code>hit</code> method that handles collision testing and
						reactions (blocking and bounce) for all types of sprites. Use one collision method for
						everything: rectangles, circles, points, and arrays of sprites.
					Easy!</li>
					<li>A companion suite of lightweight, low-level 2D geometric collision methods.</li>
					<li>A loading progress bar for game assets.</li>
					<li>Make sprites shoot things with <code>shoot</code>. </li>
					<li>Easily plot sprites in a grid formation with <code>grid</code>.</li>
					<li>Use a <code>tilingSprite</code> to easily create a seamless scrolling background.</li>
					<li>Tiled Editor support using <code>makeTiledWorld</code>. Design your game in
						Tiled Editor and access all the sprites, layers and objects directly
						in your game code. It&#39;s an extremely fun, quick and easy way to make
					games.</li>
					<li>A versatile, <code>hitTestTile</code> method that handles all the collision
						checking you&#39;ll need for tile-based games. You can use it in combination
						with the any of the 2D geometric collision methods for optimized
					broadphase/narrowphase collision checking if you want to.</li>
					<li>A <code>particleEffect</code> function for creating all kinds of particle
						effects for games. Use the <code>emitter</code> function to create a constant
					stream of particles.</li>
					<li>Use <code>updateMap</code> to keep a tile-based world&#39;s map data array up-to-date
					with moving sprites.</li>
					<li>Create a <code>worldCamera</code> that follows sprites around a scrolling game
					world.</li>
					<li>Use <code>scaleToWindow</code> to make the game automatically scale to its maximum size and align itself for the best fit inside the browser window. Use <code>enterFullscreen</code> to make the browser enter full screen mode, and <code>exitFullscreen</code> to exit full screen mode.</li>
				</ul>
				<p>To use the plugins, just copy/paste the code you want to use from <code>plugins.js</code> into your game.
					Or, if you&#39;re not worried about the extra size,
				just link the whole thing; it&#39;s really tiny anyway!</p>
				<p>If you want to get fancy, you can alternatively create your own <code>custom.js</code> file that
					contains a small custom sub-set of the plugins
					you want to use for your game. Your <code>custom.js</code> file can load at
					compile time, so it&#39;s ready to use before your game code runs.
				(See the <code>plugins.js</code> file for instructions on how to do this).</p>
				<p><a id='comingsoon'></a></p>
				<h3 id="coming-soon-">Coming soon...</h3>
				<ul>
					<li>Tiled Editor isometric maps support.</li>
					<li>Many more examples including complete game prototypes.</li>
					<li>Additional documentation, examples, and tutorials.</li>
				</ul>
				<p><a id='philosophy'></a></p>
				<h2 id="ga-s-philosophy-and-technical-constraints">Ga&#39;s philosophy and technical constraints</h2>
				<ul>
					<li>The <code>ga.js</code> core game engine file can&#39;t ever be bigger that 6.5k
						minified and zipped. Yes, 6.5k! This makes it suitable for making games for micro game
						competitions, like <a href="http://js13kgames.com">js13k</a>. This absurdly
						low overhead means you can drop a full-featured 2D action game into a web page and have it load and play almost
						instantly. But, more
						importantly, this constraint also discourages feature-creep and keeps
					the engine lean and focused. </li>
					<li>The API has to be fun, intuitive and expressive with as little
						boilerplate code as possible. Game designers should be
						free to explore their imaginations without tripping over a tangled
					and messy API. Less typing, Less thinking!</li>
					<li>The source code must be easily readable and comment-rich so that
						everyone can learn from it. It should also be architecturally flat
						so that anyone can rip it apart and easily drop it into something
					else.</li>
					<li>For the same reasons, all the source code must be hand-written written from scratch without any 3rd party dependencies (external libraries.)</li>
					<li>Any special features, like Tiled Editor support, can be added to the
						plugins.js file, so that game developers can pick and choose a
					minimal custom set of components they want for specific games without bloating the core engine.</li>
				</ul>
				<p><a id='minifying'></a></p>
				<h2 id="minifying-crushing-and-compressing">Minifying, crushing and compressing</h2>
				<p>The Ga repository doesn&#39;t include the minified and compressed version
					of the source code, because you should probably optimize that yourself. I recommend
					first minifying the code using with <a href="http://closure-compiler.appspot.com/home">Google Closure
					Compiler</a> (Simple mode only) or
					<a href="https://github.com/mishoo/UglifyJS2">UglifyJS2</a>. Google Closure will
				give you best minification, and Ga&#39;s source code is optimized for it.</p>
				<p>Then, zip it. I recommend <a href="http://www.gzip.org">gzip</a>.</p>
				<p>For more aggressive optimization, you could further try running the
					minified code through
					<a href="http://www.iteral.com/jscrush/">JSCrush</a>. Although it sometimes makes
					things worse rather than better - you&#39;ll have to test it with your
				code.</p>
				<p>Note: If you&#39;re using Google Closure Compiler from the command line, set the <code>--language_in</code>
				flag to <code>ECMASCRIPT5</code>, like this:</p>
				<p><code>java -jar ~/compiler.jar --language_in=ECMASCRIPT5 --js ga.js --js_output_file ga.min.js</code></p>
				<p><a id='contributions'></a></p>
				<h2 id="contributions-and-licencing">Contributions and Licencing</h2>
				<p>It&#39;s Ga&#39;s ambition to be the world&#39;s tiniest, cutest and funnest game engine.
					Please help! If you find something that&#39;s bad, please help to fix it.
					If you find something good, please help to make it better.  Ga
				welcomes any and all contributions! </p>
				<p>+1 Bonus Points for removing code and simplifying the architecture. +2 Bonus
					Points for making the code easier to understand. The aim of this
					project is to discover the smallest universal set of reusable
					components required to make
					the widest variety of games possible with the least amount of code.
					What is the fundamental alphabet, or the primary colours, of game design?
				That&#39;s what we&#39;re searching. Can you help?</p>
				<p>Checkout the <code>dev</code> branch to make experimental changes and bug fixes, and we&#39;ll merge it with the <code>master</code> branch when we can confirm that everything is stable. Make sure that any code changes you make are compatible with <a href="http://closure-compiler.appspot.com/home">Google Closure Compiler</a>. </p>
				<p>Please feel free to PR (Pull Request) any bug fixes and minor code improvements and optimizations. Any changes to the user-facing public API will need to be discussed in the Issues first. If we make any public API changes, we&#39;ll need to commit to updating all affected example and tutorial files as well. Also, any major changes to the engine will need to be discused too.</p>
				<p><strong>Coding style</strong>: Unconventionally, Ga
					uses <strong>functional composition</strong> patterns (the <a href="http://toddmotto.com/mastering-the-module-pattern/">module
					pattern</a> and
					<a href="http://raganwald.com/2014/04/10/mixins-forwarding-delegation.html">mixins</a>)
					for object creation instead of inheritance. Why? It&#39;s really
					just an experiment in coding like that. It also means the code
				becomes a little more compact.</p>
				<p>Licensing? Ga is vehemently <em>unlicenesed</em>.
				That means its freer than free.</p>
				<p>It&#39;s like a pebble.
				You can pick it up and throw into the sea.</p>
				<p><a id='hexi'></a></p>
				<h2 id="hexi">Hexi</h2>
				<p>Do you like Ga, but wished that it had a powerful WebGL renderer and a gazillion other features that you will probably never use? Then checkout Ga&#39;s sister game engine: <a href="https://github.com/kittykatattack/hexi">Hexi</a>. It uses almost exactly the same API as Ga, but is built on top of the latest stable version of the powerful, full-featured <a href="http://www.pixijs.com">Pixi</a> renderer. What that means is that you can prototype your games for js13k, and port 99% of that code unchanged into Hexi to build your prodction version. If you don&#39;t care about small file sizes, and need a highly flexible, mobile-optimized and production-ready game engine using the world&#39;s most streamlined API, then check out Hexi!</p>
				<p><a id='tutorials'></a></p>
				<h2 id="tutorials">Tutorials</h2>
				<p>How do you make a video game? These tutorials will show you how. </p>
				<p>But first, you should have a reasonable understanding of HTML and
					JavaScript. You don&#39;t have to be an expert, just an ambitious beginner
					with an eagerness to learn. If you don&#39;t know HTML and JavaScript, the
				best place to start learning it is this book:</p>
				<p><a href="http://www.apress.com/9781430247166">Foundation Game Design with HTML5 and JavaScript</a></p>
				<p>I know for a fact that it&#39;s the best book, because I wrote it :)</p>
				<p>There are also some good internet resources to help get you started:</p>
				<p><a href="http://www.khanacademy.org/computing/cs">Khan Academy: Computer
				Programming</a></p>
				<p><a href="http://www.codecademy.com/tracks/javascript">Code Academy:
				JavaScript</a></p>
				<p>Ok, got it?
					Do you know what JavaScript variables, functions, arrays and objects are and how to
				use them? Good, then read on!</p>
				<p><a id='treasure'></a></p>
				<h3 id="treasure-hunter">Treasure Hunter</h3>
				<p>The first game we&#39;re going to make is a simple object collection and
					enemy avoidance game called Treasure Hunter. Open the file
					<code>01_treasureHunter.html</code> in a web browser. (You&#39;ll find it in Ga&#39;s
					<code>tutorials</code> folder, and you&#39;ll need to run it in a
					<a href="https://github.com/nodeapps/http-server">webserver</a>). If you don&#39;t
					want to bother setting up a webserver, use a text-editor like
					<a href="http://brackets.io">Brackets</a> that will launch one for you
				automatically (see Brackets&#39; documentation for this feature).</p>
				<p><a href="https://cdn.rawgit.com/kittykatattack/ga/master/tutorials/01_treasureHunter.html"><img src="/tutorials/screenshots/01.png" alt="Treasure Hunter"></a></p>
				<p>(Follow the link in the image above to play the game.) Use the keyboard to move the explorer (the blue square), collect the
					treasure (the yellow square), avoid the monsters (the red squares) and
					reach the exit (the green square.) Yes, you have to use your
				imagination - for now. </p>
				<p>Don&#39;t be fooled by it&#39;s apparent simplicity. Treasure Hunter contains
				everything a video game needs:</p>
				<ul>
					<li>Interactivity</li>
					<li>Collision</li>
					<li>Sprites</li>
					<li>A game loop</li>
					<li>Scenes</li>
					<li>game logic</li>
					<li>&quot;Juice&quot; (in the form of sounds)</li>
				</ul>
				<p>(What&#39;s juice? <a href="https://www.youtube.com/watch?v=Fy0aCDmgnxg">Watch this
					video</a> and
					<a href="http://www.gamasutra.com/view/feature/130848/how_to_prototype_a_game_in_under_7_.php?print=1">read this article</a> to learn
				about this essential game design ingredient.)</p>
				<p>If you can make a simple game like Treasure Hunter, you can make
					almost any other kind of game. Yes, really! Getting from Treasure
					Hunter to Skyrim or Zelda
					is just a matter of lots of small steps; adding more
				detail as you go. How much detail you want to add is up to you. </p>
				<p>In the first stage of this tutorial you&#39;ll learn how the basic
					Treasure Hunter game was made, and then we&#39;ll add some fun features like images and
					character animation that will give you a complete overview of how the
				Ga game engine works. </p>
				<p>If you&#39;re an experienced game programmer and
					quick self-starter, you might find the code in Ga&#39;s <code>examples</code> folder to
					be a more productive place to start learning - check it out. The fully
					commented
					code in the <code>examples</code> folder also details specific, and advanced uses
					of features, that aren&#39;t
					covered in these tutorials. When you&#39;re finished working through these
					tutorials, the <code>examples</code> will take you on the next stage of your
				journey.</p>
				<p><a id='setingup'></a></p>
				<h4 id="setting-up-the-html-container-page">Setting up the HTML container page</h4>
				<p>Before you can start programming in JavaScript, you need to set up a
					minimal HTML container page. The HTML page loads <code>ga.js</code> and
					<code>plugins.js</code> which are the two files you need to use all of Ga&#39;s
					features. You&#39;ll write all your game code inside the last pair of
				<code>&lt;script&gt;</code> tags before the closing <code>&lt;body&gt;</code> tag.</p>
				<pre><code class="lang-js">&lt;!doctype html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Treasure hunter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-comment">&lt;!-- Import the Ga game engine files --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../ga.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../plugins.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">

<span class="hljs-comment">//All of your game code will go here</span>

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
</code></pre>
				<p>This is the <a href="http://stackoverflow.com/questions/9797046/whats-a-valid-html5-document">minimum amount of HTML code you need for a valid HTML5
				document</a>.</p>
				<p><a id='initializing'></a></p>
				<h4 id="initializing-the-ga-engine">Initializing the Ga engine</h4>
				<p>The next step is to write some JavaScript code that initializes and starts the Ga game
					engine, according to some parameters that you specify. This bit of
					code below initializes a game with a screen size of 512 by 512 pixels.
					It also pre-loads the <code>chimes.wav</code> sound file from the <code>sounds</code>
				folder.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
  <span class="hljs-number">512</span>, <span class="hljs-number">512</span>, setup,
  [
    <span class="hljs-string">"sounds/chimes.wav"</span>
  ]
);

<span class="hljs-comment">//Start the Ga engine.</span>
g.start();
</code></pre>
				<p>You can see that the result of the <code>ga</code> function is being assigned to
				an variable called <code>g</code>. </p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
</code></pre>
				<p>Now, whenever you want to use any of Ga&#39;s custom
					methods or objects in your game, just prefix it with <code>g</code>. (You don&#39;t
					have to use <code>g</code> to represent the game engine, you can use any variable
					name you want. <code>g</code> is just nice, short, and easy to remember; <code>g</code> =
				&quot;game&quot;.)</p>
				<p>In this example Ga creates a canvas element with a size of 512 by 512
				pixels. That&#39;s specified by the first two arguments:</p>
				<pre><code class="lang-js"><span class="hljs-number">512</span>, <span class="hljs-number">512</span>, setup,
</code></pre>
				<p>The third argument, <code>setup</code>, means that as soon as Ga is initialized,
					it should look for and run a function in your game code called <code>setup</code>.
					Whatever code is in the <code>setup</code> function is entirely up to you, and
					you&#39;ll soon see how you can used it to initialize a game. (You don&#39;t
				have to call this function <code>setup</code>, you can use any name you like.) </p>
				<p>Ga lets you pre-load game assets with an optional 4th argument, which
					is an array of file names. In this first example, you only need to preload one file: <code>chimes.wav</code>
					You can see that the full file path to <code>chimes.wav</code> is listed as a
					string in the
				initialization array:</p>
				<pre><code class="lang-js">[
  <span class="hljs-string">"sounds/chimes.wav"</span>
]
</code></pre>
				<p>You can list as many game assets as you like here, including images,
					fonts, and JSON files. Ga will load all these assets for you before
				running any of the game code.</p>
				<p>The last thing you need to do is call Ga&#39;s <code>start</code> method. </p>
				<pre><code class="lang-js">g.start();
</code></pre>
				<p>This is the switch that turns the Ga engine on.</p>
				<p><a id='definingglobals'></a></p>
				<h4 id="define-your-global-variables">Define your &quot;global&quot; variables</h4>
				<p>After Ga has been started, declare all the variables that your game
				functions will need to use.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> dungeon, player, treasure, enemies, chimes, exit,
    healthBar, message, gameScene, gameOverScene;
</code></pre>
				<p>Because they&#39;re not enclosed inside a function, these variables are &quot;global&quot;
					in the sense that you can use them across all of your game functions.
					(They&#39;re not necessarily &quot;global&quot; in the sense that they inhabit the
					global JavaScript name-space. If you want to ensure that they aren&#39;t, <a href="http://stackoverflow.com/questions/17058606/why-using-self-executing-function-in-javascript">wrap all of
						your JavaScript code in an enclosing <strong>immediate function</strong> to isolate it
						from the global
				space</a>.</p>
				<p><a id='setupfunction'></a></p>
				<h4 id="initialize-your-game-with-a-setup-function">Initialize your game with a setup function</h4>
				<p>As soon as Ga starts, it will look for and run a function in your game
					code called <code>setup</code> (or whatever other name you want to give this
					function.) The <code>setup</code> function is only run once, and lets you perform
					one-time setup tasks for your game. It&#39;s a great place to create and initialize
					objects, create sprites, game scenes, populate data arrays or parse
				loaded JSON game data. </p>
				<p>Here&#39;s an abridged, birds-eye view of the <code>setup</code> function in Treasure Hunter,
				and the tasks that it performs.</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setup</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//Set the canvas border and background color</span>
  <span class="hljs-comment">//Create the `chimes` sound object</span>
  <span class="hljs-comment">//Create the `gameScene` group</span>
  <span class="hljs-comment">//Create the `exit` door sprite</span>
  <span class="hljs-comment">//Create the `player` sprite</span>
  <span class="hljs-comment">//Create the `treasure` sprite</span>
  <span class="hljs-comment">//Make the enemies</span>
  <span class="hljs-comment">//Create the health bar</span>
  <span class="hljs-comment">//Add some text for the game over message</span>
  <span class="hljs-comment">//Create a `gameOverScene` group </span>
  <span class="hljs-comment">//Assign the player's keyboard controllers</span>

  <span class="hljs-comment">//set the game state to `play`</span>
  g.state = play;
}
</code></pre>
				<p>The last line of code, <code>g.state = play</code> is perhaps the most important
					because it starts the <code>play</code> function. The <code>play</code> function runs all the game logic
					in a loop. But before we look at how that works, let&#39;s see what the
				specific code inside the <code>setup</code> function does.</p>
				<p><a id='customizing'></a></p>
				<h5 id="customizing-the-canvas">Customizing the canvas</h5>
				<p>The first two lines in the <code>setup</code> function give the canvas a black dashed border and set its
				background color to white.</p>
				<pre><code class="lang-js">g.canvas.style.border = <span class="hljs-string">"1px black dashed"</span>;
g.backgroundColor = <span class="hljs-string">"white"</span>;
</code></pre>
				<p>Here&#39;s the effect these two lines have on the Ga canvas:</p>
				<p><img src="/tutorials/screenshots/02.png" alt="Treasure Hunter"></p>
				<p>Ga uses an ordinary 2D canvas element to display the game graphics,
					and you can access it in your code at any time with <code>g.canvas</code>. You
				can modify it with any ordinary HTML/CSS properties.</p>
				<p><a id='creatingsound'></a></p>
				<h5 id="creating-the-chimes-sound-object">Creating the <code>chimes</code> sound object</h5>
				<p>You&#39;ll remember from the code above that we preloaded a sound file
					into the game called <code>chimes.wav</code>. Before you can use it in your game,
					you have to make a reference to it using Ga&#39;s <code>sound</code> method,
				like this:</p>
				<pre><code class="lang-js">chimes = g.sound(<span class="hljs-string">"sounds/chimes.wav"</span>);
</code></pre>
				<p>Alternatively, you can access any assets that you&#39;ve loaded via Ga&#39;s
				<code>assets</code> object, like this:</p>
				<pre><code class="lang-js">g.assets[<span class="hljs-string">"sounds/chimes.wav"</span>]
</code></pre>
				<p>Any assets that you&#39;ve preloaded like this are accessible in the
				<code>assets</code> object.</p>
				<p>Many assets that you might want to use, like sounds, fonts, and JSON
					files, can
					only be loaded by the browser if your code is running inside a
					web server. If you&#39;re trying to load or use an asset, and the browser is
					giving your a
					strange security related error message, check to make sure that the
				web server is initialized.</p>
				<p><a id='gamescenes'></a></p>
				<h5 id="creating-game-scenes">Creating game scenes</h5>
				<p>Ga has a useful method called <code>group</code> that lets you group game objects
					together so that you can work with them as one unit. Groups are used for
					grouping together special objects called <strong>sprites</strong>  (which you&#39;ll
				learn all about in the next section.) But they&#39;re also used for making game scenes. </p>
				<p>Treasure Hunter uses two game scenes: <code>gameScene</code> which is the main game,
					and <code>gameOverScene</code> which is displayed when the game is finished.
				Here&#39;s how the <code>gameScene</code> is made using the <code>group</code> method:</p>
				<pre><code class="lang-js">gameScene = g.group();
</code></pre>
				<p>After you&#39;ve made the group, you can add sprites (game objects) to the <code>gameScene</code>, using
				the <code>addChild</code> method.</p>
				<pre><code class="lang-js">gameScene.addChild(anySprite);
</code></pre>
				<p>Or, you can add multiple sprites at one time with the <code>add</code> method, like this:</p>
				<pre><code class="lang-js">gameScene.add(spriteOne, spriteTwo, spriteThree);
</code></pre>
				<p>Or, if you prefer, you can create the game scene after you&#39;ve made all
				the sprites, and group all the sprites together with one line of code, like this:</p>
				<pre><code class="lang-js">gameScene = g.group(spriteOne, spriteTwp, spriteThree);
</code></pre>
				<p>You&#39;ll see a few different examples of how to add sprites to groups in
				the examples ahead.</p>
				<p>But what are sprites, and how do you make them?</p>
				<p><a id='makingsprites'></a></p>
				<h5 id="making-sprites">Making sprites</h5>
				<p>Sprites are the most important elements in any game. Sprites are
					just graphics (shapes or images) that you can control with
					special properties. Everything you can see in your games, like
					game characters, objects and backgrounds, are sprites. Ga lets you make
					5 kinds of basic sprites: <code>rectangle</code>, <code>circle</code>, <code>line</code>, <code>text</code>, and
					<code>sprite</code> (an image-based sprite). You can make almost any 2D action game
					with these basic sprite types. (If they aren&#39;t enough, you can also define your own custom
					sprite types.) This first version of Treasure Hunter
					only uses <code>rectangle</code> sprites. You can make a rectangle sprite like
				this:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> box = g.rectangle(
  widthInPixels, 
  heightInPixels, 
  <span class="hljs-string">"fillColor"</span>, 
  <span class="hljs-string">"strokeColor"</span>, 
  lineWidth, 
  xPosition, 
  yPosition
);
</code></pre>
				<p>You can use Ga&#39;s <code>circle</code> method to make a circular shaped sprite:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> ball = g.circle(
  diameterInPixels, 
  <span class="hljs-string">"fillColor"</span>, 
  <span class="hljs-string">"strokeColor"</span>, 
  lineWidth,
  xPosition, 
  yPosition 
);
</code></pre>
				<p>It&#39;s often useful to prototype a new game using only <code>rectangle</code> and
					<code>circle</code> sprites, because that can help you focus on the mechanics of your
					game in a pure, elemental way. That&#39;s what this first version of
					Treasure Hunter does. Here&#39;s the code from the <code>setup</code> function that
				creates the <code>exit</code>, <code>player</code> and <code>treasure</code> sprites.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//The exit door</span>
exit = g.rectangle(<span class="hljs-number">48</span>, <span class="hljs-number">48</span>, <span class="hljs-string">"green"</span>);
exit.x = <span class="hljs-number">8</span>;
exit.y = <span class="hljs-number">8</span>;
gameScene.addChild(exit);

<span class="hljs-comment">//The player sprite</span>
player = g.rectangle(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-string">"blue"</span>);
player.x = <span class="hljs-number">68</span>;
player.y = g.canvas.height / <span class="hljs-number">2</span> - player.halfHeight;
gameScene.addChild(player);

<span class="hljs-comment">//Create the treasure sprite</span>
treasure = g.rectangle(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-string">"gold"</span>);

<span class="hljs-comment">//Position the treasure next to the right edge of the canvas</span>
treasure.x = g.canvas.width - treasure.width - <span class="hljs-number">32</span>;
treasure.y = g.canvas.height / <span class="hljs-number">2</span> - treasure.halfHeight;

<span class="hljs-comment">//Create a `pickedUp` property on the treasure to help us figure</span>
<span class="hljs-comment">//out whether or not the treasure has been picked up by the player</span>
treasure.pickedUp = <span class="hljs-literal">false</span>;

<span class="hljs-comment">//Add the treasure to the gameScene</span>
gameScene.addChild(treasure);
</code></pre>
				<p>Notice that after each sprite is created, it&#39;s added to the
				<code>gameScene</code> using <code>addChild</code>. Here&#39;s what the above code produces:</p>
				<p><img src="/tutorials/screenshots/03.png" alt="Treasure Hunter"></p>
				<p>Let&#39;s find out a little more about how these sprites are positioned on
				the canvas.</p>
				<p><a id='positioningsprites'></a></p>
				<h5 id="positioning-sprites">Positioning sprites</h5>
				<p>All sprites have <code>x</code> and <code>y</code> properties that you can use to precisely
					position sprites on the canvas. The <code>x</code> and <code>y</code> values refer to the sprites&#39; pixel
					coordinates relative to the canvas&#39;s top left corner. The top
					left corner has <code>x</code> and <code>y</code> values of 0. That means any
					positive <code>x</code> and <code>y</code> values you assign to sprites will position them left (<code>x</code>) and down
					(<code>y</code>) relative to that corner point. For example, Here&#39;s the
				code that positions the <code>exit</code> door (the green square). </p>
				<pre><code class="lang-js">exit.x = <span class="hljs-number">8</span>;
exit.y = <span class="hljs-number">8</span>;
</code></pre>
				<p>You can see that this code places the door 8 pixel to the right and 8 pixels below the
					canvas&#39;s top left corner. Positive <code>x</code> values position sprites to the
					right of the canvas&#39;s left edge. Positive <code>y</code> values position them
				below the canvas&#39;s top edge.</p>
				<p>Sprites also have <code>width</code> and <code>height</code>
					properties that tell you their width and height in pixels. If you need
					to find out what half the width or half the height of a sprite is, use
				<code>halfWidth</code> and <code>halfHeight</code>.</p>
				<p>Ga also has a some convenience methods that help you quickly position
					sprites relative to other sprites: <code>putTop</code>, <code>putRight</code>, <code>putBottom</code>, <code>putLeft</code> and <code>putCenter</code>.
					For example, here are the lines from the code above that
					position the treasure sprite (the gold box). The code places the
					treasure 26 pixels to the left of the
				canvas&#39;s right edge, and centers it vertically.</p>
				<pre><code class="lang-js">treasure.x = g.canvas.width - treasure.width - <span class="hljs-number">32</span>;
treasure.y = g.canvas.height / <span class="hljs-number">2</span> - treasure.halfHeight;
</code></pre>
				<p>That&#39;s a lot of complicated positioning code to write. Instead, you
					could use Ga&#39;s built-in <code>putCenter</code> method to achieve the same effect
				like this:</p>
				<pre><code class="lang-js">g.stage.putCenter(treasure, <span class="hljs-number">220</span>, <span class="hljs-number">0</span>);
</code></pre>
				<p>What is the <code>stage</code>? It&#39;s the root container for all the sprites, and
					has exactly the same dimensions as the canvas. You can think of the
					<code>stage</code> as
					a big, invisible sprite, the same size as the canvas, that contains
					all the sprites in your game, as well as any containers those sprites
					might be grouped in (Like the <code>gameScene</code>). <code>putCenter</code> works by
					centering the <code>treasure</code> inside the <code>stage</code>, and then offsetting its
				<code>x</code> position by 220 pixels. Here&#39;s the format for using <code>putCenter</code>:</p>
				<pre><code class="lang-js">anySprite.putCenter(anyOtherSprite, xOffset, yOffset);
</code></pre>
				<p>You can use the other <code>put</code> methods in the same way. For example, if
					you wanted to position a sprite directly to the left of another
				sprite, without any offset, you could use <code>putLeft</code>, like this:</p>
				<pre><code class="lang-js">spriteOne.putLeft(spriteTwo);
</code></pre>
				<p>This would place <code>spriteTwo</code> directly to the left of <code>spriteOne</code>, and
					align it vertically .You&#39;ll see many examples of how to use these <code>put</code> methods throughout
				these tutorials.</p>
				<p><a id='dynamicproperties'></a></p>
				<h5 id="assigning-dynamic-properties">Assigning dynamic properties</h5>
				<p>Before we continue, there&#39;s one small detail you need to notice. The
					code that creates the sprites also adds a <code>pickedUp</code> property to the
				<code>treasure</code> sprite:</p>
				<pre><code class="lang-js">treasure.pickedUp = <span class="hljs-literal">false</span>;
</code></pre>
				<p>You&#39;ll see how we&#39;re going to use <code>treasure.pickedUp</code> later in the game logic to help us determine the
				progress of the game. You can dynamically assign any custom properties or methods to sprites like this, if you need to.</p>
				<p><a id='enemysprites'></a></p>
				<h5 id="creating-the-enemy-sprites">Creating the enemy sprites</h5>
				<p>There are 6 enemies sprites (red squares) in Treasure Hunter. They&#39;re
					spaced evenly horizontally but but have random initial vertical
					positions. All the enemies sprites are created in a <code>for</code> loop using
				this code in the <code>setup</code> function:</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Make the enemies</span>
<span class="hljs-keyword">var</span> numberOfEnemies = <span class="hljs-number">6</span>,
    spacing = <span class="hljs-number">48</span>,
    xOffset = <span class="hljs-number">150</span>,
    speed = <span class="hljs-number">2</span>,
    direction = <span class="hljs-number">1</span>;

enemies = [];

<span class="hljs-comment">//Make as many enemies as there are `numberOfEnemies`</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numberOfEnemies; i++) {

  <span class="hljs-comment">//Each enemy is a red rectangle</span>
  <span class="hljs-keyword">var</span> enemy = g.rectangle(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-string">"red"</span>);

  <span class="hljs-comment">//Space each enemey horizontally according to the `spacing` value.</span>
  <span class="hljs-comment">//`xOffset` determines the point from the left of the screen</span>
  <span class="hljs-comment">//at which the first enemy should be added.</span>
  <span class="hljs-keyword">var</span> x = spacing * i + xOffset;

  <span class="hljs-comment">//Give the enemy a random y position</span>
  <span class="hljs-keyword">var</span> y = g.randomInt(<span class="hljs-number">0</span>, g.canvas.height - enemy.height);

  <span class="hljs-comment">//Set the enemy's direction</span>
  enemy.x = x;
  enemy.y = y;

  <span class="hljs-comment">//Set the enemy's vertical velocity. `direction` will be either `1` or</span>
  <span class="hljs-comment">//`-1`. `1` means the enemy will move down and `-1` means the enemy will</span>
  <span class="hljs-comment">//move up. Multiplying `direction` by `speed` determines the enemy's</span>
  <span class="hljs-comment">//vertical direction</span>
  enemy.vy = speed * direction;

  <span class="hljs-comment">//Reverse the direction for the next enemy</span>
  direction *= <span class="hljs-number">-1</span>;

  <span class="hljs-comment">//Push the enemy into the `enemies` array</span>
  enemies.push(enemy);

  <span class="hljs-comment">//Add the enemy to the `gameScene`</span>
  gameScene.addChild(enemy);
}
</code></pre>
				<p>Here&#39;s what this code produces:</p>
				<p><img src="/tutorials/screenshots/04.png" alt="Treasure Hunter"></p>
				<p>The code gives each of the enemies a random <code>y</code> position with the help
				of Ga&#39;s <code>randomInt</code> method:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> y = g.randomInt(<span class="hljs-number">0</span>, g.canvas.height - enemy.height);
</code></pre>
				<p><code>randomInt</code> will give you a random number between any two integers that you
					provide in the arguments. (If you need a random decimal number, use
				<code>randomFloat</code> instead).</p>
				<p>All sprites have properties called <code>vx</code> and <code>vy</code>. They determine the
					speed and direction that the sprite will move in the horizontal
					direction (<code>vx</code>) and vertical direction (<code>vy</code>).  The enemies in
					Treasure Hunter only move up and down, so they just need a <code>vy</code> value.
					Their <code>vy</code> is <code>speed</code> (2) multiplied by <code>direction</code> (which will be
				either <code>1</code> or <code>-1</code>).</p>
				<pre><code class="lang-js">enemy.vy = speed * direction;
</code></pre>
				<p>If <code>direction</code> is <code>1</code>, the enemy&#39;s <code>vy</code> will be <code>2</code>. That means the
					enemy will move down the screen at a rate of 2 pixels per frame. If
					<code>direction</code> is <code>-1</code>, the enemy&#39;s speed will be <code>-2</code>. That means the
				enemy will move up the screen at 2 pixels per frame. </p>
				<p>After the enemy&#39;s <code>vy</code> is set, <code>direction</code> is reversed so that the next
				enemy will move in the opposite direction.</p>
				<pre><code class="lang-js">direction *= <span class="hljs-number">-1</span>;
</code></pre>
				<p>You can see that each enemy that&#39;s created is pushed into an array
				called <code>enemies</code>.</p>
				<pre><code class="lang-js">enemies.push(enemy);
</code></pre>
				<p>Later in the code you&#39;ll see how we&#39;ll access all the enemies in this
				array to figure out if they&#39;re touching the player.</p>
				<p><a id='healthbar'></a></p>
				<h5 id="the-health-bar">The health bar</h5>
				<p>You&#39;ll notice that when the player
					touches one of the enemies, the width of the health bar at the top right corner of
				the screen decreases. </p>
				<p><img src="/tutorials/screenshots/05.png" alt="Treasure Hunter"></p>
				<p>How was this health bar made? It&#39;s just two rectangle sprites at the same
					position: a black rectangle behind, and a green rectangle in front. They&#39;re grouped
					together to make a single compound sprite called <code>healthBar</code>. The
				<code>healthBar</code> is then added to the <code>gameScene</code>.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Create the health bar</span>
<span class="hljs-keyword">var</span> outerBar = g.rectangle(<span class="hljs-number">128</span>, <span class="hljs-number">16</span>, <span class="hljs-string">"black"</span>),
    innerBar = g.rectangle(<span class="hljs-number">128</span>, <span class="hljs-number">16</span>, <span class="hljs-string">"yellowGreen"</span>);

<span class="hljs-comment">//Group the inner and outer bars</span>
healthBar = g.group(outerBar, innerBar);

<span class="hljs-comment">//Set the `innerBar` as a property of the `healthBar`</span>
healthBar.inner = innerBar;

<span class="hljs-comment">//Position the health bar</span>
healthBar.x = g.canvas.width - <span class="hljs-number">148</span>;
healthBar.y = <span class="hljs-number">16</span>;

<span class="hljs-comment">//Add the health bar to the `gameScene`</span>
gameScene.addChild(healthBar);
</code></pre>
				<p>You can see that a property called <code>inner</code> has been added to the
					<code>healthBar</code>. It just references the <code>innerBar</code> (the green rectangle) so that
				it will be convenient to access later.</p>
				<pre><code class="lang-js">healthBar.inner = innerBar;
</code></pre>
				<p>You don&#39;t <em>have</em> to do this; but, hey why not! It means that if you
					want to control the width of the <code>innerBar</code>, you can write some smooth code
				that looks like this:</p>
				<pre><code class="lang-js">healthBar.inner.width = <span class="hljs-number">30</span>;
</code></pre>
				<p>That&#39;s pretty neat and readable, so we&#39;ll keep it!</p>
				<p><a id='gameoverscene'></a></p>
				<h5 id="the-game-over-scene">The game over scene</h5>
				<p>If the player&#39;s health drops to zero, or the player manages to
					carry the treasure to the exit, the game ends and the game over screen
					is displayed.  The game over scene is just some text that displays &quot;You won!&quot; or &quot;You
				lost!&quot; depending on the outcome. </p>
				<p><img src="/tutorials/screenshots/06.png" alt="Treasure Hunter"></p>
				<p>How was this made? The text is made with a <code>text</code> sprite. </p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> anyText = g.text(
  <span class="hljs-string">"Hello!"</span>, <span class="hljs-string">"CSS font properties"</span>, <span class="hljs-string">"fillColor"</span>, xPosition, yPosition
);
</code></pre>
				<p>The first argument, &quot;Hello!&quot; in the above example, is the text content
					you want to display. Use the <code>content</code> property to change the text
				sprite&#39;s content later.</p>
				<pre><code class="lang-js">anyText.content = <span class="hljs-string">"Some new content"</span>;
</code></pre>
				<p>Here&#39;s how the game over message text is created in the <code>setup</code>
				function. </p>
				<pre><code class="lang-js"><span class="hljs-comment">//Add some text for the game over message</span>
message = g.text(<span class="hljs-string">"Game Over!"</span>, <span class="hljs-string">"64px Futura"</span>, <span class="hljs-string">"black"</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);
message.x = <span class="hljs-number">120</span>;
message.y = g.canvas.height / <span class="hljs-number">2</span> - <span class="hljs-number">64</span>;
</code></pre>
				<p>Next, a new <code>group</code> is created called <code>gameOverScene</code>. The <code>message</code> text
					is added to it. The <code>gameOverScene</code>&#39;s <code>visible</code> property is set to
				<code>false</code> so that it&#39;s not visible when the game first starts.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Create a `gameOverScene` group and add the message sprite to it</span>
gameOverScene = g.group(message);

<span class="hljs-comment">//Make the `gameOverScene` invisible for now</span>
gameOverScene.visible = <span class="hljs-literal">false</span>;
</code></pre>
				<p>At the end of the game we&#39;ll set the <code>gameOverScene</code>&#39;s <code>visible</code>
					property to <code>true</code> to display the text message. We&#39;ll also set the
					<code>gameScene</code>&#39;s <code>visible</code> property to <code>false</code> so that all the game
				sprites are hidden.</p>
				<p><a id='keyboard'></a></p>
				<h5 id="keyboard-interactivity">Keyboard interactivity</h5>
				<p>You control the player (the blue square) with the keyboard arrow keys.
					Ga has a built-in <code>key</code> object with keyboard bindings
					to the arrow keys and space bar. Access them like this:
					<code>key.leftArray</code>, <code>key.rightArrow</code>, <code>key.upArrow</code>, <code>key.downArrow</code>,
					<code>key.space</code>. All these keys have <code>press</code> and
					<code>release</code> methods that you can define. Here&#39;s code in the <code>setup</code>
				function that customizes the <code>press</code> and <code>release</code> methods of<br>Ga&#39;s pre-defined arrow keys to control the player character: </p>
				<pre><code class="lang-js"><span class="hljs-comment">//Left arrow key `press` method</span>
g.key.leftArrow.press = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//Change the player's velocity when the key is pressed</span>
  player.vx = <span class="hljs-number">-5</span>;
  player.vy = <span class="hljs-number">0</span>;
};

<span class="hljs-comment">//Left arrow key `release` method</span>
g.key.leftArrow.release = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//If the left arrow has been released, and the right arrow isn't down,</span>
  <span class="hljs-comment">//and the player isn't moving vertically:</span>
  <span class="hljs-comment">//Stop the player</span>
  <span class="hljs-keyword">if</span> (!g.key.rightArrow.isDown &amp;&amp; player.vy === <span class="hljs-number">0</span>) {
    player.vx = <span class="hljs-number">0</span>;
  }
};

g.key.upArrow.press = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  player.vy = <span class="hljs-number">-5</span>;
  player.vx = <span class="hljs-number">0</span>;
};

g.key.upArrow.release = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!g.key.downArrow.isDown &amp;&amp; player.vx === <span class="hljs-number">0</span>) {
    player.vy = <span class="hljs-number">0</span>;
  }
};

g.key.rightArrow.press = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  player.vx = <span class="hljs-number">5</span>;
  player.vy = <span class="hljs-number">0</span>;
};

g.key.rightArrow.release = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!g.key.leftArrow.isDown &amp;&amp; player.vy === <span class="hljs-number">0</span>) {
    player.vx = <span class="hljs-number">0</span>;
  }
};

g.key.downArrow.press = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  player.vy = <span class="hljs-number">5</span>;
  player.vx = <span class="hljs-number">0</span>;
};

g.key.downArrow.release = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!g.key.upArrow.isDown &amp;&amp; player.vx === <span class="hljs-number">0</span>) {
    player.vy = <span class="hljs-number">0</span>;
  }
};
</code></pre>
				<p>You can see that the value of the player&#39;s <code>vx</code> and <code>vy</code> properties is
					changed depending on which keys are being pressed or released.
					A positive <code>vx</code> value will make the player move right, a negative
					value will make it move left. A positive <code>vy</code> value will make the
					player move
				down, a negative value will make it move up. </p>
				<p>Is that too much typing? Because controlling a player character with 4
					keyboard keys is such a common requirement, Ga has a built-in function called
				<code>fourKeyController</code> that accomplishes all this in one line of code.</p>
				<pre><code class="lang-js">g.fourKeyController(player, <span class="hljs-number">5</span>, <span class="hljs-number">38</span>, <span class="hljs-number">39</span>, <span class="hljs-number">40</span>, <span class="hljs-number">37</span>);
</code></pre>
				<p>The first argument is the sprite you want to control: <code>player</code>. The
					second argument is the number of pixels that the sprite should move each frame: <code>5</code>.
					The last four arguments are the <a href="http://www.asciitable.com">ascii key code numbers</a> for the top,
					right, bottom and left keys. (You can remember this because their
				order is listed clockwise, starting from the top.)</p>
				<p>Reference to the arrow keys and space key are built-in to Ga, but you
					if want to use other keys, you can easily create and assign your own
				with Ga&#39;s <code>keyboard</code> method:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> customKey = g.keyboard(asciiCode);
</code></pre>
				<p>Your new <code>customKey</code> has <code>press</code> and <code>release</code> methods
				that you can program in the same way as the examples above. </p>
				<p><a id='gamestate'></a></p>
				<h5 id="setting-the-game-state">Setting the game state</h5>
				<p>The <strong>game state</strong> is the function that Ga is currently running. When
					Ga first starts, it runs the <code>setup</code> function (or whatever other
					function you specify in Ga&#39;s constructor function arguments.) If you
					want to change the game state, assign a new function to Ga&#39;s <code>state</code>
				property. Here&#39;s how:</p>
				<pre><code class="lang-js">g.state = anyFunction;
</code></pre>
				<p>In Treasure Hunter, when the <code>setup</code> function is finished, the game
				<code>state</code> is set to <code>play</code>:</p>
				<pre><code>g.<span class="hljs-keyword">state</span> = play;
</code></pre><p>This makes Ga look for and run a function called <code>play</code>. By default,
					any function assigned to the game state will run in a continuous loop, at
					60 frames per second. (You can change the frame rate at any time by setting Ga&#39;s
					<code>fps</code> property). Game logic usually runs in a continuous loop, which
					is known as the <strong>game loop</strong>. Ga handles the loop management for you,
					so you don&#39;t need to worry about how it works. (In case you&#39;re curious, Ga uses
					a <code>requestAnimationFrame</code> loop with a <a href="http://gameprogrammingpatterns.com/game-loop.html">fixed logic time step and variable rendering time</a>. It
					also does sprite position interpolation to smoothe out any inconsistent
				spikes in the frame rate.)</p>
				<p>If you ever need to pause the loop, just use Ga&#39;s <code>pause</code>method, like
				this:</p>
				<pre><code class="lang-js">g.pause();
</code></pre>
				<p>You can start the game loop again with the <code>resume</code> method, like this:</p>
				<pre><code>g.resume()<span class="hljs-comment">;</span>
</code></pre><p>Now let&#39;s find out how Treasure Hunter&#39;s <code>play</code> function works. </p>
				<p><a id='gamelogic'></a></p>
				<h4 id="game-logic-with-the-play-function-loop">Game logic with the play function loop</h4>
				<p>As you&#39;ve just learned, everything in the <code>play</code> function runs in a
				continuous loop.</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//This code loops from top to bottom 60 times per second  </span>
}
</code></pre>
				<p>This is where all the game logic happens. It&#39;s the fun part,
				so let&#39;s find out what the code inside the <code>play</code> function does.</p>
				<p><a id='movingplayer'></a></p>
				<h5 id="moving-the-player-sprite">Moving the player sprite</h5>
				<p>Treasure Hunter uses Ga&#39;s <code>move</code> method inside the <code>play</code> function to move the sprites in the
				game.</p>
				<pre><code class="lang-js">g.move(player);
</code></pre>
				<p>This is the equivalent of writing code like this:</p>
				<pre><code class="lang-js">player.x += player.vx;
player.y += player.vy;
</code></pre>
				<p>It just updates the player&#39;s <code>x</code> and <code>y</code> position by adding its <code>vx</code>
					and <code>vy</code> velocity values. (Remember, those values were
					set by the key <code>press</code> and <code>release</code> methods.) Using <code>move</code> just saves
					you from having to type-in and look-at this very standard boilerplate
				code.</p>
				<p>You can also move a whole array of sprites with one line of code by
				supplying the array as the argument.</p>
				<pre><code class="lang-js">g.move(arrayOfSprites);
</code></pre>
				<p>So now you can easily move the player, but what happens when the
				player reaches the edges of the screen?</p>
				<p><a id='boundries'></a></p>
				<h5 id="containing-sprites-inside-the-screen-boundaries">Containing sprites inside the screen boundaries</h5>
				<p>Use Ga&#39;s <code>contain</code> method to keep sprites inside the boundaries of
				the screen.</p>
				<pre><code class="lang-js">g.contain(player, g.stage.localBounds);
</code></pre>
				<p>The first argument is the sprite you want to contain, and the second
					argument is any JavaScript object with an <code>x</code>, <code>y</code>, <code>width</code>, and
					<code>height</code> property. As a convenience, all Ga sprites have a property
				called <code>localBounds</code> that return an object with this information.</p>
				<p>As you learnt earlier, <code>stage</code> is the root container object for all Ga&#39;s sprites, and it has
					the same width and height as the <code>canvas</code>. That means you can use its
				<code>localBounds</code> property to keep the sprite contained inside the canvas.</p>
				<p>But you can alternatively supply a custom object to do the same thing. Here&#39;s how:</p>
				<pre><code class="lang-js">g.contain(
  player, 
  {
    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">512</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">512</span>
  }
);
</code></pre>
				<p>This will contain the <code>player</code> sprite to an area defined by the
					dimensions of the object. This is really convenient if you want to
				precisely fine-tune the area in which the object should be contained.</p>
				<p><code>contain</code> has an extra useful feature. If the sprite reaches one of
					the containment edges, <code>contain</code> will return a string that tells you
					which edge it reached: &quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, or &quot;left&quot;. Here&#39;s how
					you could use this feature to find out which edge of the canvas the
				sprite is touching:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> playerHitsEdges = g.contain(player, g.stage.localBounds);

<span class="hljs-comment">//Display the edge of canvas that the player hit</span>
<span class="hljs-keyword">if</span> (playerHitsEdges) {
  message.content 
    = <span class="hljs-string">"The player hit the "</span> + playerHitsEdges + <span class="hljs-string">" of the canvas"</span>;
}
</code></pre>
				<p><a id='collisionenemy'></a></p>
				<h5 id="collision-with-the-enemies">Collision with the enemies</h5>
				<p>When the player hits any of the enemies, the width of the health bar
				decreases and the player becomes semi-transparent.</p>
				<p><img src="/tutorials/screenshots/07.png" alt="Treasure Hunter"></p>
				<p>How does this work?</p>
				<p>Ga has a full suite of useful 2D geometric and tile-based collision
					detection methods. You can read all about them in Ga&#39;s <code>examples</code>
					folder. Treasure Hunter only uses one of these collision methods:
					<code>hitTestRectangle</code>. It takes two rectangular sprites and tells you
					whether they&#39;re overlapping. It will return <code>true</code> if they are, and
				<code>false</code> if they aren&#39;t.</p>
				<pre><code><span class="hljs-selector-tag">g</span><span class="hljs-selector-class">.hitTestRectangle</span>(<span class="hljs-selector-tag">spriteOne</span>, <span class="hljs-selector-tag">spriteTwo</span>);
</code></pre><p>Here&#39;s how the code in the <code>play</code> function uses <code>hitTestRectangle</code> to
				check for a collision between any of the enemies and the player.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Set `playerHit` to `false` before checking for a collision</span>
<span class="hljs-keyword">var</span> playerHit = <span class="hljs-literal">false</span>;

<span class="hljs-comment">//Loop through all the sprites in the `enemies` array</span>
enemies.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">enemy</span>) </span>{

  <span class="hljs-comment">//Move the enemy</span>
  g.move(enemy);

  <span class="hljs-comment">//Check the enemy's screen boundaries</span>
  <span class="hljs-keyword">var</span> enemyHitsEdges = g.contain(enemy, g.stage.localBounds);

  <span class="hljs-comment">//If the enemy hits the top or bottom of the stage, reverse</span>
  <span class="hljs-comment">//its direction</span>
  <span class="hljs-keyword">if</span> (enemyHitsEdges === <span class="hljs-string">"top"</span> || enemyHitsEdges === <span class="hljs-string">"bottom"</span>) {
    enemy.vy *= <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">//Test for a collision. If any of the enemies are touching</span>
  <span class="hljs-comment">//the player, set `playerHit` to `true`</span>
  <span class="hljs-keyword">if</span>(g.hitTestRectangle(player, enemy)) {
    playerHit = <span class="hljs-literal">true</span>;
  }
});

<span class="hljs-comment">//If the player is hit...</span>
<span class="hljs-keyword">if</span>(playerHit) {

  <span class="hljs-comment">//Make the player semi-transparent</span>
  player.alpha = <span class="hljs-number">0.5</span>;

  <span class="hljs-comment">//Reduce the width of the health bar's inner rectangle by 1 pixel</span>
  healthBar.inner.width -= <span class="hljs-number">1</span>;

} <span class="hljs-keyword">else</span> {

  <span class="hljs-comment">//Make the player fully opaque (non-transparent) if it hasn't been hit</span>
  player.alpha = <span class="hljs-number">1</span>;
}
</code></pre>
				<p>This bit of code creates a variable called <code>playerHit</code>, which is
					initialized to <code>false</code> just before the <code>forEach</code> loop checks all the
				enemies for a collision.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> playerHit = <span class="hljs-literal">false</span>;
</code></pre>
				<p>(Because the <code>play</code> function runs 60 times per second, <code>playerHit</code>
				will be reinitialized to <code>false</code> on every new frame.)</p>
				<p>If <code>hitTestRectangle</code> returns <code>true</code>, the <code>forEach</code> loop sets
				<code>playerHit</code> to <code>true</code>.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span>(g.hitTestRectangle(player, enemy)) {
  playerHit = <span class="hljs-literal">true</span>;
}
</code></pre>
				<p>If the player has been hit, the code makes the player semi-transparent by
					setting its <code>alpha</code> value to 0.5. It also reduces the width of the
				<code>healthBar</code>&#39;s <code>inner</code> sprite by 1 pixel.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span>(playerHit) {

  <span class="hljs-comment">//Make the player semi-transparent</span>
  player.alpha = <span class="hljs-number">0.5</span>;

  <span class="hljs-comment">//Reduce the width of the health bar's inner rectangle by 1 pixel</span>
  healthBar.inner.width -= <span class="hljs-number">1</span>;

} <span class="hljs-keyword">else</span> {

  <span class="hljs-comment">//Make the player fully opaque (non-transparent) if it hasn't been hit</span>
  player.alpha = <span class="hljs-number">1</span>;
}
</code></pre>
				<p>You can set the <code>alpha</code> property of sprites to any value between <code>0</code>
					(fully transparent) to <code>1</code> (fully opaque). A value of <code>0.5</code> makes it
					semi-transparent.b (<strong>Alpha</strong> is a
				well-worn graphic design term that just means <strong>transparency</strong>.)</p>
				<p>This bit of code also uses the <code>move</code> method to move the enemies, and
					<code>contain</code> to keep them contained inside the canvas. The code also uses
					the return value of <code>contain</code> to find out if the enemy is hitting the
					top or bottom of the canvas. If it hits the top or bottom, the enemy&#39;s direction is
				reversed with the help of this code:</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Check the enemy's screen boundaries</span>
<span class="hljs-keyword">var</span> enemyHitsEdges = g.contain(enemy, g.stage.localBounds);

<span class="hljs-comment">//If the enemy hits the top or bottom of the stage, reverse</span>
<span class="hljs-comment">//its direction</span>
<span class="hljs-keyword">if</span> (enemyHitsEdges === <span class="hljs-string">"top"</span> || enemyHitsEdges === <span class="hljs-string">"bottom"</span>) {
  enemy.vy *= <span class="hljs-number">-1</span>;
}
</code></pre>
				<p>Multiplying the enemy&#39;s <code>vy</code> (vertical velocity) value by negative 1
					makes it go in the opposite direction. It&#39;s a really simple <strong>bounce</strong>
				effect.</p>
				<p><a id='collisiontreasure'></a></p>
				<h6 id="collision-with-the-treasure">Collision with the treasure</h6>
				<p>If the player touches the treasure (the yellow square), the <code>chimes</code>
					sound plays. The player can then
					carry the treasure to the exit. The treasure is centered over the player and
				moves along with it. </p>
				<p><img src="/tutorials/screenshots/08.png" alt="Treasure Hunter"></p>
				<p>Here&#39;s the code from the <code>play</code> function that achieves these effects.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Check for a collision between the player and the treasure</span>
<span class="hljs-keyword">if</span> (g.hitTestRectangle(player, treasure)) {

  <span class="hljs-comment">//If the treasure is touching the player, center it over the player</span>
  treasure.x = player.x + <span class="hljs-number">8</span>;
  treasure.y = player.y + <span class="hljs-number">8</span>;

  <span class="hljs-keyword">if</span>(!treasure.pickedUp) {

    <span class="hljs-comment">//If the treasure hasn't already been picked up,</span>
    <span class="hljs-comment">//play the `chimes` sound</span>
    chimes.play();
    treasure.pickedUp = <span class="hljs-literal">true</span>;
  };
}
</code></pre>
				<p>You can see that the code uses <code>hitTestRectangle</code> inside an <code>if</code>
				statement to test for a collision between the player and the treasure.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span> (g.hitTestRectangle(player, treasure)) {
</code></pre>
				<p>If it&#39;s <code>true</code>, the treasure is centered over the player.</p>
				<pre><code class="lang-js">treasure.x = player.x + <span class="hljs-number">8</span>;
treasure.y = player.y + <span class="hljs-number">8</span>;
</code></pre>
				<p>If <code>treasure.pickedUp</code> is <code>false</code>, then you know that the treasure hasn&#39;t already been
				picked up, and you can play the <code>chimes</code> sound:</p>
				<pre><code class="lang-js">chimes.play();
</code></pre>
				<p>In addition to <code>play</code> Ga&#39;s sound objects also have a few more methods that you can use to control them:
					<code>pause</code>, <code>restart</code> and <code>playFrom</code>. (Use <code>playFrom</code> to start playing
					the sound from a specific second in the sound file, like this:
					<code>soundObject.playFrom(5)</code>. This will make the sound start playing from
				the 5 second mark.)</p>
				<p>You can also set the sound object&#39;s <code>volume</code> by assigning
					a value between 0 and 1. Here&#39;s how to set the <code>volume</code> to mid-level
				(50%).</p>
				<pre><code class="lang-js">soundObject.volume = <span class="hljs-number">0.5</span>;
</code></pre>
				<p>You can set the sound object&#39;s <code>pan</code> by assigning a value between -1 (left speaker)
					to 1 (right speaker). A pan value of 0 makes the sound equal volume in
					both speakers. Here&#39;s how you could set the <code>pan</code> to be slightly more
				prominent in the left speaker.</p>
				<pre><code class="lang-js">soundObject.pan = <span class="hljs-number">-0.2</span>;
</code></pre>
				<p>If you want to make a sound repeat continuously, set its <code>loop</code> property to <code>true</code>.</p>
				<pre><code class="lang-js">soundObject.loop = <span class="hljs-literal">true</span>;
</code></pre>
				<p>Ga uses a <a href="https://gist.github.com/kittykatattack/cd41b480e94fd32d8ad5">lightweight wrapper for the WebAudio
					API</a> to achieve all these
				effects.</p>
				<p>Because you don&#39;t want to play the <code>chimes</code> sound more than once after
					the treasure has been picked up, the code sets <code>treasure.pickedUp</code> to
				<code>true</code> just after the sound plays.</p>
				<pre><code class="lang-js">treasure.pickedUp = <span class="hljs-literal">true</span>;
</code></pre>
				<p>Now that the player has picked up the treasure, how can you check for
				the end of the game?</p>
				<p><a id='endinggame1'></a></p>
				<h5 id="ending-the-game">Ending the game</h5>
				<p>There are two ways the game can end. The player&#39;s health can run out,
					in which case the game is lost. Or, the player can successfully carry
					the treasure to the exit, in which case the game is won. If either of
					these two conditions are met,  the game&#39;s <code>state</code> is set to <code>end</code> and
					the <code>message</code> text&#39;s <code>content</code> displays the outcome. Here&#39;s the last
				bit of code in the <code>play</code> function that does this:</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Does the player have enough health? If the width of the `innerBar`</span>
<span class="hljs-comment">//is less than zero, end the game and display "You lost!"</span>
<span class="hljs-keyword">if</span> (healthBar.inner.width &lt; <span class="hljs-number">0</span>) {
  g.state = end;
  message.content = <span class="hljs-string">"You lost!"</span>;
}

<span class="hljs-comment">//If the player has brought the treasure to the exit,</span>
<span class="hljs-comment">//end the game and display "You won!"</span>
<span class="hljs-keyword">if</span> (g.hitTestRectangle(treasure, exit)) {
  g.state = end;
  message.content = <span class="hljs-string">"You won!"</span>;
}
</code></pre>
				<p>The <code>end</code> function is really simple. It just hides the <code>gameScene</code> and
				displays the <code>gameOverScene</code>.</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params"></span>) </span>{
  gameScene.visible = <span class="hljs-literal">false</span>;
  gameOverScene.visible = <span class="hljs-literal">true</span>;
}
</code></pre>
				<p>And that&#39;s it for Treasure Hunter! Before you continue, try making
					your own game from scratch using some of these same techniques. When
				you&#39;re ready, read on!</p>
				<p><a id='usingimages'></a></p>
				<h3 id="using-images">Using images</h3>
				<p>There are three main ways you can use images in your Ga games. </p>
				<ul>
					<li>Use individual image files for each sprite.</li>
					<li>Use a <strong>texture atlas</strong>. This is a single image file that includes
						sub-images for each sprite in your game. The image file is
						accompanied by a matching JSON
						data file that describes the name, size and location of each
					sub-image.</li>
					<li>Use a <strong>tileset</strong> (also known as a <strong>spritesheet</strong>). This is also a single
						image file that includes sub-images for each sprite. However, unlike a
						texture atlas, it doesn&#39;t come with a JSON file describing the
						sprite data. Instead, you need to specify the size and location of
						each sprite in your game code with JavaScript. This can have some
					advantages over a texture atlas in certain circumstances.</li>
				</ul>
				<p>All three ways of making image sprites use Ga&#39;s <code>sprite</code> method.
				Here&#39;s the simplest way of using it to make an image sprite.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> imageSprite = g.sprite(<span class="hljs-string">"images/theSpriteImage.png"</span>);
</code></pre>
				<p>In
					this next section we&#39;ll update Treasure Hunter with image sprites, and
				you&#39;ll learn all three ways of adding images to your games.</p>
				<p>(All the images in this section were created by Lanea Zimmerman. You
					can find more of her artwork
					<a href="http://opengameart.org/users/sharm">here</a>.
				Thanks, Lanea!)</p>
				<p><a id='individualimages'></a></p>
				<h4 id="individual-images">Individual images</h4>
				<p>Open and play the next version of Treasure Hunter:
					<code>02_treasureHunterImages.html</code> (you&#39;ll find it in the <code>tutorials</code>
					folder.) It plays exactly the same as the first version, but all the
				colored squares have been replaced by images.</p>
				<p><a href="https://cdn.rawgit.com/kittykatattack/ga/master/tutorials/02_treasureHunterImages.html"><img src="/tutorials/screenshots/09.png" alt="Treasure Hunter"></a></p>
				<p>(Click the image and follow the link to play the game.) Take a look at the source code, and you&#39;ll notice that the game logic
					and structure is exactly the same as the first version of the game.
					The only thing that&#39;s changed is the appearance of the sprites.
				How was this done?</p>
				<p><a id='loadingimagefile'></a></p>
				<h5 id="loading-image-files">Loading image files</h5>
				<p>Each sprite in the game uses an individual PNG image file. You&#39;ll find
				all the images in the tutorials&#39; <code>images</code> sub-folder.</p>
				<p><img src="/tutorials/screenshots/10.png" alt="Treasure Hunter"></p>
				<p>Before you can use them to make sprites, you need to pre-load them into
					Ga&#39;s <code>assets</code>. The easiest way to do this is to list the image names,
					with their full file paths, in Ga&#39;s assets array when you first
				initialize the engine.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
  <span class="hljs-number">512</span>, <span class="hljs-number">512</span>, setup,
  [
    <span class="hljs-string">"images/explorer.png"</span>,
    <span class="hljs-string">"images/dungeon.png"</span>,
    <span class="hljs-string">"images/blob.png"</span>,
    <span class="hljs-string">"images/treasure.png"</span>,
    <span class="hljs-string">"images/door.png"</span>,
    <span class="hljs-string">"sounds/chimes.wav"</span>
  ]
);
g.start();
</code></pre>
				<p>(If you open up the JavaScript console in the web browser, you can
				monitor the loading progress of these assets.)</p>
				<p>Now you can access any of these images in your game code like this:</p>
				<pre><code class="lang-js">g.image(<span class="hljs-string">"images/blob.png"</span>)
</code></pre>
				<p>This is just a short-cut for accessing the image directly in the
				<code>assets</code> object like this:</p>
				<pre><code class="lang-js">g.assets[<span class="hljs-string">"images/blob.png"</span>]
</code></pre>
				<p>You can use whichever style you prefer. In any case, the image file
					is just an ordinary JavaScript <code>Image</code> object, so you can use
				it the same way you would any other <code>Image</code> object. </p>
				<p>Although pre-loading the images and other assets is the simplest way
					to get them into your game, you can also load assets at any other time
					using the <code>assets</code> object&#39;s <code>load</code> method. Just supply an array of strings
				that list the asset names and their file paths.</p>
				<pre><code class="lang-js">g.assets.load([
  <span class="hljs-string">"images/imageOne.png"</span>, 
  <span class="hljs-string">"images/imageTwo.png"</span>,
  <span class="hljs-string">"sounds/chimes.wav"</span>
]);
</code></pre>
				<p>Next, assign a callback function called <code>whenLoaded</code> that will run when the assets have
				loaded. </p>
				<pre><code class="lang-js">g.assets.whenLoaded = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//Do something when the assets have loaded</span>
};
</code></pre>
				<p>Now that you&#39;ve loaded the images into the game, let&#39;s find out how to
				use them to make sprites.</p>
				<p><a id='makingsprites'></a></p>
				<h5 id="making-sprites-with-images">Making sprites with images</h5>
				<p>Create an image sprite using the <code>sprite</code> method using the same format you learnt
					earlier. Here&#39;s how to create a sprite using the <code>dungeon.png</code> image.
				(<code>dungeon.png</code> is a 512 by 512 pixel background image.)</p>
				<pre><code><span class="hljs-attribute">dungeon</span> = g.sprite(<span class="hljs-string">"images/dungeon.png"</span>)<span class="hljs-comment">;</span>
</code></pre><p>That&#39;s all! Now instead of displaying as a simple colored rectangle,
					the sprite will be displayed as a 512 by 512 image. There&#39;s no need
					to specify the width or height, because Ga figures that our for you
					automatically based on the size of the image. You can use all the other
					sprite properties, like <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code>, just as you
				would with ordinary rectangle sprites. </p>
				<p>Here&#39;s the code from the <code>setup</code> function that creates the dungeon
					background, exit door, player and treasure, and adds them all to the
				<code>gameScene</code> group. </p>
				<pre><code class="lang-js"><span class="hljs-comment">//The dungeon background</span>
dungeon = g.sprite(<span class="hljs-string">"images/dungeon.png"</span>);

<span class="hljs-comment">//The exit door</span>
exit = g.sprite(<span class="hljs-string">"images/door.png"</span>);
exit.x = <span class="hljs-number">32</span>;

<span class="hljs-comment">//The player sprite</span>
player = g.sprite(<span class="hljs-string">"images/explorer.png"</span>);
player.x = <span class="hljs-number">68</span>;
player.y = g.canvas.height / <span class="hljs-number">2</span> - player.halfWidth;

<span class="hljs-comment">//Create the treasure</span>
treasure = g.sprite(<span class="hljs-string">"images/treasure.png"</span>);

<span class="hljs-comment">//Position it next to the left edge of the canvas</span>
treasure.x = g.canvas.width - treasure.width - <span class="hljs-number">32</span>;
treasure.y = g.canvas.height / <span class="hljs-number">2</span> - treasure.halfHeight;

<span class="hljs-comment">//Create a `pickedUp` property on the treasure to help us Figure</span>
<span class="hljs-comment">//out whether or not the treasure has been picked up by the player</span>
treasure.pickedUp = <span class="hljs-literal">false</span>;

<span class="hljs-comment">//Create the `gameScene` group and add all the sprites</span>
gameScene = g.group(dungeon, exit, player, treasure);
</code></pre>
				<p>(As a slightly more efficient improvement to the
					original version of this code, <code>group</code> creates the <code>gameScene</code> and groups
				the sprites in a single step.)</p>
				<p>Look familiar? That&#39;s right, the only code that has changed are the
					lines that create the sprites. This modularity is a feature of Ga that lets you create quick
					game prototypes using simple shapes that you can easily swap out for
					detailed images as your game ideas develops. The rest of the code in the
				game can remain as-is.</p>
				<p><a id='finetuning'></a></p>
				<h5 id="fine-tuning-the-containment-area">Fine-tuning the containment area</h5>
				<p>One small improvement that was made to this new version Treasure
					Hunter is the new way that the sprites are contained inside the walls of the
					dungeon. They&#39;re contained in such a way that naturally matches the 2.5D perspective of the
				artwork, as shown by the green square in this screen shot:</p>
				<p><img src="/tutorials/screenshots/11.png" alt="Treasure Hunter"></p>
				<p>This is a very easy modification to make. All you need to do is supply
					the <code>contain</code> method with a custom object that defines the size and
				position of the containing rectangle. Here&#39;s how:</p>
				<pre><code class="lang-js">g.contain(
  player,
  {
    <span class="hljs-attr">x</span>: <span class="hljs-number">32</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">16</span>,
    <span class="hljs-attr">width</span>: g.canvas.width - <span class="hljs-number">32</span>,
    <span class="hljs-attr">height</span>: g.canvas.height - <span class="hljs-number">32</span>
  }
);
</code></pre>
				<p>Just tweak the <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code> values so that the
				containing area looks natural for the game you&#39;re making.</p>
				<p><a id='textureatlas'></a></p>
				<h4 id="using-a-texture-atlas">Using a texture atlas</h4>
				<p>If youre working on a big, complex game, youll want a fast and
					efficient way to work with images. A texture atlas can help you do
					this. A texture atlas is actually two separate files that are closely
				related:</p>
				<ul>
					<li>A single PNG <strong>tileset</strong> image file that contains all the images you
						want to use in your game. (A tileset image is sometimes called a
					spritesheet.)</li>
					<li>A JSON file that describes the size and position of those sub-images
					in the tileset.</li>
				</ul>
				<p>Using a texture atlas is a big time saver. You can arrange the
					tilesets sub-images in any order and the JSON file will keep
					track of their sizes and positions for you. This is really convenient
					because it means the sizes and positions of the sub-images arent
					hard-coded into your game program. If you make changes to the tileset,
					like adding images, resizing them, or removing them, just re-publish
					the JSON file and your game will use that updated data to display the
					images correctly. If youre going to be making anything bigger than a
				very small game, youll definitely want to use a texture atlas.</p>
				<p>The de-facto standard for tileset JSON data is the format that is
					output by a popular software tool called <a href="https://www.codeandweb.com/texturepacker">Texture Packer</a> (Texture
					Packer&#39;s &quot;Essential&quot; license is free ). Even if you
					dont use Texture Packer, similar tools like <a href="http://renderhjs.net/shoebox/">Shoebox</a> output JSON files
					in the same format. Lets find out how to use it to make a texture
				atlas with Texture Packer, and how to load it into a game.</p>
				<p><a id='preparingimages'></a></p>
				<h5 id="preparing-the-images">Preparing the images</h5>
				<p>You first need individual PNG images for each image in your game.
					You&#39;ve already got them for Treasure Hunter, so you&#39;re all set. Open Texture
					Packer and choose the {JS} configuration option. Drag your game images
					into its workspace. You can also point Texture Packer to any folder that contains
					your images. Texture Packer will automatically arrange the images on a
					single tileset image, and give them names that match their original
				image file names. It will give them a 2 pixel padding by default.</p>
				<p><img src="/tutorials/screenshots/12.png" alt="Texture Packer"></p>
				<p>Each of the sub-images in the atlas is called a <strong>frame</strong>. Although
					it&#39;s just one big image, the texture atlas has 5 frames. The name of each
					frame is the same its original PNG file name: &quot;dungeon.png&quot;,
					&quot;blob.png&quot;, &quot;explorer.png&quot;, &quot;treasure.png&quot; and &quot;door.png&quot;. These
				frames names are used to help the atlas reference each sub-image.</p>
				<p>When youre done, make sure the Data Format is set to JSON (Hash) and
					click the Publish button. Choose the file name and location, and save the
					published files. Youll end up with a PNG file and a JSON file. In
					this example my file names are <code>treasureHunter.json</code> and
					<code>treasureHunter.png</code>. To make
					your life easier, just keep both files in your projects <code>images</code>
				folder. (Think of the JSON file as extra metadata for the image file.)</p>
				<p><a id='loadingatlas'></a></p>
				<h5 id="loading-the-texture-atlas">loading the texture atlas</h5>
				<p>To load the texture atlas into your game, just include the JSON file
				in Ga&#39;s assets array when you initialize the game.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
  <span class="hljs-number">512</span>, <span class="hljs-number">512</span>, setup,
  [
    <span class="hljs-string">"images/treasureHunter.json"</span>,
    <span class="hljs-string">"sounds/chimes.wav"</span>
  ]
);
g.start();
</code></pre>
				<p>That&#39;s all! You don&#39;t have to load the PNG file - Ga does that
					automatically in the background. The JSON file is all you need to tell
				Ga which tileset frame (sub-image) to display.</p>
				<p>Now if you want to use a frame from the texture atlas to make a
				sprite, you can do it like this:</p>
				<pre><code class="lang-js">anySprite = g.sprite(<span class="hljs-string">"frameName.png"</span>);
</code></pre>
				<p>Ga will create the sprite and display the correct image from the
				texture atlas&#39;s tileset.</p>
				<p>Here&#39;s how to you could create the sprites in Treasure Hunter using
				texture atlas frames:</p>
				<pre><code class="lang-js"><span class="hljs-comment">//The dungeon background image</span>
dungeon = g.sprite(<span class="hljs-string">"dungeon.png"</span>);

<span class="hljs-comment">//The exit door</span>
exit = g.sprite(<span class="hljs-string">"door.png"</span>);
exit.x = <span class="hljs-number">32</span>;

<span class="hljs-comment">//The player sprite</span>
player = g.sprite(<span class="hljs-string">"explorer.png"</span>);
player.x = <span class="hljs-number">68</span>;
player.y = g.canvas.height / <span class="hljs-number">2</span> - player.halfWidth;

<span class="hljs-comment">//The treasure</span>
treasure = g.sprite(<span class="hljs-string">"treasure.png"</span>);
</code></pre>
				<p>That&#39;s all! Ga knows that those are texture atlas frame names, not individual
				images, and it displays them directly from the tileset.</p>
				<p>If you ever need to access the texture atlas&#39;s JSON file in your game,
				you can get it like this:</p>
				<pre><code class="lang-js">jsonFile = g.json(<span class="hljs-string">"jsonFileName.json"</span>);
</code></pre>
				<p>Take a look at <code>treasureHunterAtlas.html</code> file in the <code>tutorials</code> folder
					to see a working example of how to load a texture atlas and use it to
				make sprites.</p>
				<p><a id='alienarmada'></a></p>
				<h3 id="alien-armada">Alien Armada</h3>
				<p>The next example game in this series of tutorials is Alien Armada. Can you
					destroy 60 aliens before one of them lands and destroys the Earth? Click the
				image link below to play the game:</p>
				<p><a href="https://cdn.rawgit.com/kittykatattack/ga/master/tutorials/04_alienArmada.html"><img src="/tutorials/screenshots/13.png" alt="Alien Armada"></a></p>
				<p>Use the arrow keys to move and press the space bar to shoot. The
					aliens descend from the top of the screen with
				increasing frequency as the game progresses. Here&#39;s how the game is played:</p>
				<p><img src="/tutorials/screenshots/14.png" alt="Alien Armada gameplay"></p>
				<p>Alien Armada illustrates some new techniques that you&#39;ll definitely want
				to use in your games:</p>
				<ul>
					<li>Load and use custom fonts.</li>
					<li>Automatically scale and center the game to the browser window. </li>
					<li>Display a loading progress bar while the game assets load.</li>
					<li>Shoot bullets.</li>
					<li>Create sprites with multiple image states.</li>
					<li>Generate random enemies.</li>
					<li>Remove sprites from a game.</li>
					<li>Display a game score.</li>
					<li>Reset and restart a game.</li>
				</ul>
				<p>You&#39;ll find the fully commented Alien Armada source code in the
					<code>tutorials</code> folder. Make sure to take a look at it so that you can see
					all of this code in its proper context. Its general structure is identical
					to Treasure Hunter, with the addition of these new techniques. Let&#39;s
				find out how they were implemented.</p>
				<p><a id='customfonts'></a></p>
				<h4 id="load-and-use-a-custom-font">Load and use a custom font</h4>
				<p>Alien Armada uses a custom font called <code>emulogic.ttf</code> to display the
					score at the top right corner of the screen. The font file is
					preloaded with the rest of the asset files (sounds and images) in the assets array that
				initializes the game. </p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
  <span class="hljs-number">480</span>, <span class="hljs-number">320</span>, setup,
  [
    <span class="hljs-string">"images/alienArmada.json"</span>,
    <span class="hljs-string">"sounds/explosion.mp3"</span>,
    <span class="hljs-string">"sounds/music.mp3"</span>,
    <span class="hljs-string">"sounds/shoot.mp3"</span>,
    <span class="hljs-string">"fonts/emulogic.ttf"</span>  <span class="hljs-comment">//&lt;- The custom font.</span>
  ],
  load
);
</code></pre>
				<p>To use the font, create a <code>text</code> sprite in the game&#39;s <code>setup</code>
					function. The <code>text</code> method&#39;s second argument is a
				string that describes the font&#39;s point size and name: &quot;20px emulogic&quot;.  </p>
				<pre><code class="lang-js">scoreDisplay = g.text(<span class="hljs-string">"0"</span>, <span class="hljs-string">"20px emulogic"</span>, <span class="hljs-string">"#00FF00"</span>, <span class="hljs-number">400</span>, <span class="hljs-number">10</span>);
</code></pre>
				<p>You can and load and use any fonts in TTF, OTF, TTC or WOFF format.</p>
				<p><a id='scalebrowser'></a></p>
				<h4 id="scale-and-center-the-game-in-the-browser">Scale and center the game in the browser</h4>
				<p>You&#39;ll notice that when you play Alien Armada, the game is centered
					inside the browser window, and automatically fills to the window&#39;s maximum
				width and height.</p>
				<p><img src="/tutorials/screenshots/15.png" alt="Alien Armada gameplay"></p>
				<p>The browser background that borders the game is set to a dark gray
					color. This
					is thanks to one of Ga&#39;s built-in features: the
					<code>scaleToWindow</code> method. To use it, call <code>scaleToWindow</code> just after
				you call Ga&#39;s <code>start</code> method, like this:</p>
				<pre><code class="lang-js">g.start();
g.scaleToWindow();
</code></pre>
				<p><code>scaleToWindow</code> will center your game for the best fit. Long, wide
					game screens are centered vertically. Tall or square screens are
					centered horizontally. If you want to specify your own browser
					background color that borders the game, supply it in <code>scaleToWindow</code>&#39;s
				arguments, like this:</p>
				<pre><code class="lang-js">g.scaleToWindow(<span class="hljs-string">"seaGreen"</span>);
</code></pre>
				<p>For best results, make sure you set the default margins and paddings
					on all your HTML elements to <code>0</code>. The following bit of CSS does the
				trick: </p>
				<pre><code class="lang-js">&lt;style&gt; * {<span class="hljs-attr">margin</span>: <span class="hljs-number">0</span>; padding: <span class="hljs-number">0</span>;} &lt;<span class="hljs-regexp">/style&gt;</span>
</code></pre>
				<p>Here&#39;s how this <code>&lt;style&gt;</code> tag is inserted into Alien Armada&#39;s HTML
				container page:</p>
				<pre><code class="lang-js">&lt;!doctype html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Alien Armada<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"> * {<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;} </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
				<p>Optionally, if you want to make sure that your game dynamically
					re-sizes and re-centers itself if the user changes the browser window
				size, just drop in this bit of code: </p>
				<pre><code class="lang-js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{
  g.scaleToWindow();
});
</code></pre>
				<p>Add it just after you&#39;ve
					called <code>scaleToWindow</code> the first time. Here&#39;s what all this code looks
				like in context:</p>
				<pre><code class="lang-js"><span class="hljs-comment">//...Initialize Ga...</span>

g.start();
g.scaleToWindow();
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{ 
  g.scaleToWindow();
});

<span class="hljs-comment">//...The rest of your game code...</span>
</code></pre>
				<p>If you want to find out how it works, or you want to customize it further, you&#39;ll
				find the <code>scaleToWindow</code> method in Ga&#39;s <code>plugins.js</code> file. </p>
				<p><a id='progressbar'></a></p>
				<p>####A loading progress bar</p>
				<p>Alien Armada loads three MP3 sound files: a shooting sound, an
					explosion sound, and music. The music sound is about 2 MB in size so
					on a slow network connection this sound could take a few seconds to
					load. While this is happening players would just see the blank canvas while Alien Armada
					loads. Some players might think the game has frozen, so the game
					helpfully implements a loading bar to inform
					players that the assets are loading. It&#39;s a blue rectangle that expands from left to right, and
					displays a number that tells you the percentage of game assets
				loaded so far.</p>
				<p><img src="/tutorials/screenshots/16.png" alt="Loading progress bar"></p>
				<p>This is a feature that&#39;s built into the Ga engine.
					Ga has a optional loading state that runs while game assets are being
					loaded. You can decide what you want to have happen during the loading
					state. All you need to do is write a function with code that should
					run while the assets are loading, and tell Ga what the name of that
					function is. Ga&#39;s engine will automatically run that function in a
				loop until the assets have finished loading.</p>
				<p>Let&#39;s find out how this works in Alien Armada. The game code tells
					Ga to use a function called <code>load</code> during the loading state. It does
					this by listing <code>load</code> as the final argument
				in Ga&#39;s initialization constructor. (Look for <code>load</code> in the code below):</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
  <span class="hljs-number">480</span>, <span class="hljs-number">320</span>, setup,
  [
    <span class="hljs-string">"images/alienArmada.json"</span>,
    <span class="hljs-string">"sounds/explosion.mp3"</span>,
    <span class="hljs-string">"sounds/music.mp3"</span>,
    <span class="hljs-string">"sounds/shoot.mp3"</span>,
    <span class="hljs-string">"fonts/emulogic.ttf"</span>
  ],
  load  <span class="hljs-comment">//&lt;- This is the function that will run while loading.</span>
);
</code></pre>
				<p>This tells Ga to run the <code>load</code> function in a loop while the assets
				are loading. </p>
				<p>Here&#39;s the <code>load</code> function from Alien Armada. It creates a <code>progressBar</code> object, and then calls the progress bar&#39;s
				<code>update</code> method each frame. </p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span>{

    <span class="hljs-comment">//Use Ga's built in `progressBar` to display a loading progress</span>
    <span class="hljs-comment">//percentage bar while the assets are loading.</span>
    g.progressBar.create(g.canvas, g.assets);

    <span class="hljs-comment">//Call the `progressBar`'s `update` method each frame. </span>
    g.progressBar.update();
}
</code></pre>
				<p>After the assets have loaded, the <code>setup</code> state runs automatically. The first
					thing it does is call the <code>progressBar</code>&#39;s <code>remove</code> method to make the
				bar disappear:</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setup</span>(<span class="hljs-params"></span>) </span>{

  g.progressBar.remove();

  <span class="hljs-comment">//... the rest of the setup function...</span>
}
</code></pre>
				<p>You&#39;ll find the <code>progressBar</code> code in the <code>plugins.js</code> file. It&#39;s
					meant to be a very simple example that you can use as the basis for
					writing your own custom loading animation, if you want to. You can run any code you
					like in the <code>load</code> function, so it&#39;s entirely up to you to decide what
				should happen or what is displayed while your game is loading.</p>
				<p><a id='shootingbullets'></a></p>
				<h4 id="shooting-bullets">Shooting bullets</h4>
				<p>How can you make the cannon fire bullets? </p>
				<p>When you press the space bar, the cannon fires bullets at the enemies.
					The bullets start from the end of the cannon&#39;s turret, and travel up the
					canvas at 7 pixels per frame. If they hit an alien, the alien
					explodes. If a bullet misses and flies past the top of the stage, the
				game code removes it.</p>
				<p><img src="/tutorials/screenshots/17.png" alt="Firing bullets"></p>
				<p>To implement a bullet-firing system in your game, the first thing you
				need is an array to store the all the bullet sprites.</p>
				<pre><code class="lang-js">bullets = [];
</code></pre>
				<p>This <code>bullets</code> array is initialized in the game&#39;s <code>setup</code> function.</p>
				<p>You can then use Ga&#39;s custom <code>shoot</code> method to make any sprite fire
					bullets in any direction. Here&#39;s the general format you can use to
				implement the <code>shoot</code> method.</p>
				<pre><code class="lang-js">g.shoot(
  cannon,      <span class="hljs-comment">//The shooting sprite</span>
  <span class="hljs-number">4.71</span>,        <span class="hljs-comment">//The angle, in radians, at which to shoot (4.71 is up)</span>
  <span class="hljs-number">16</span>,          <span class="hljs-comment">//The bullet's offset from the center of the sprite</span>
  <span class="hljs-number">7</span>,           <span class="hljs-comment">//The bullet's speed (pixels per frame)</span>
  bullets,     <span class="hljs-comment">//The array used to store the bullets</span>

  <span class="hljs-comment">//A function that returns the sprite that should</span>
  <span class="hljs-comment">//be used to make each bullet</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> g.sprite(<span class="hljs-string">"bullet.png"</span>);
  }
);
</code></pre>
				<p>The second argument determines the angle, in radians, at which the
					bullet should travel. 4.71 radians, used in this example, is up. 0 is
				to the right, 1.57 is down, and 3.14 is to the left.</p>
				<p>The last argument is a function that returns a sprite that should be
					used as the bullet. In this example the bullet is created using using the
				&quot;bullet.png&quot; frame from the game&#39;s loaded texture atlas.</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> g.sprite(<span class="hljs-string">"bullet.png"</span>);
}
</code></pre>
				<p>Replace this function with your own to create any kind of custom
				bullet you might need.</p>
				<p>When will your bullets be fired? You can call the <code>shoot</code> method
					whenever you want to make bullets, at any point in your code. In Alien
					Armada, bullets are fired when the player presses the space key. So
					the game implements this by calling <code>shoot</code> inside the space key&#39;s
				<code>press</code> method. Here&#39;s how:</p>
				<pre><code class="lang-js">g.key.space.press = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  g.shoot(
    cannon,      <span class="hljs-comment">//The shooting sprite</span>
    <span class="hljs-number">4.71</span>,        <span class="hljs-comment">//The angle at which to shoot (4.71 is up)</span>
    <span class="hljs-number">16</span>,          <span class="hljs-comment">//The bullet's offset from the center</span>
    <span class="hljs-number">7</span>,           <span class="hljs-comment">//The bullet's speed (pixels per frame)</span>
    bullets,     <span class="hljs-comment">//The array used to store the bullets</span>

    <span class="hljs-comment">//A function that returns the sprite that should</span>
    <span class="hljs-comment">//be used to make each bullet</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> g.sprite(<span class="hljs-string">"bullet.png"</span>);
    }
  );

  <span class="hljs-comment">//Play the shoot sound.</span>
  shootSound.play();
};
</code></pre>
				<p>You can see that the <code>press</code> method also makes the <code>shootSound</code> play.
				(The code above is initialized in the game&#39;s <code>setup</code> function.)</p>
				<p>There&#39;s one more thing you need to do: you have to make the bullets move.
					You can do this with some code inside the game&#39;s looping <code>play</code> function. Use Ga&#39;s
				<code>move</code> method and supply the <code>bullets</code> array as an argument:</p>
				<pre><code class="lang-js">g.move(bullets);
</code></pre>
				<p>The <code>move</code> method automatically loops through all the sprites in the
				array and updates their x and y positions with the value of their <code>vx</code> and <code>vy</code> velocity values.</p>
				<p>So now you know how the bullets are created and animated. But what happens when
				they hit one of the aliens?</p>
				<p><a id='spritestates'></a></p>
				<h4 id="sprite-states">Sprite states</h4>
				<p>When a bullet hits an alien, a yellow explosion image appears. This
					simple effect is created by giving each alien sprite two states: a <code>normal</code>
					state and a <code>destroyed</code> state. Aliens are created with their states
				set to <code>normal</code>. If they&#39;re hit, their states change to <code>destroyed</code>.</p>
				<p><img src="/tutorials/screenshots/18.png" alt="The sprite&#39;s states"></p>
				<p>How does this system work?</p>
				<p>First, let&#39;s take a look at the Alien Armada tileset, shown here:</p>
				<p><img src="/tutorials/screenshots/19.png" alt="The Alien Armada tileset"></p>
				<p>You can see two image frames that define these two states: <code>alien.png</code>
					and <code>explosion.png</code>. Before you create the sprite, first create an
				array that lists these two frames: </p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> alienFrames = [
  <span class="hljs-string">"alien.png"</span>, 
  <span class="hljs-string">"explosion.png"</span>
];
</code></pre>
				<p>Next use the <code>alienFrames</code> array to initialize the <code>alien</code> sprite.</p>
				<pre><code class="lang-js">alien = g.sprite(alienFrames);
</code></pre>
				<p>If you prefer, you could combine these two steps into one, like this:</p>
				<pre><code class="lang-js">alien = g.sprite([
  <span class="hljs-string">"alien.png"</span>, 
  <span class="hljs-string">"explosion.png"</span>
]);
</code></pre>
				<p>This loads the sprite up with two frames. Frame <code>0</code> is the <code>alien.png</code>
					frame, and frame <code>1</code> is the <code>explosion.png</code> frame. Frame <code>0</code> is
				displayed by default by when the sprite is first created. </p>
				<p>You can use the sprite&#39;s <code>show</code> method to display any other frame number on the
				sprite, like this:</p>
				<pre><code class="lang-js">alien.show(<span class="hljs-number">1</span>);
</code></pre>
				<p>The code above will set the alien to frame number one, which is the
				<code>explosion.png</code> frame.</p>
				<p>To make your code a little more readable, its a good idea to define
					your sprite&#39;s states in a special <code>states</code> object. Give each state a
					name, with a value that corresponds to that state&#39;s frame number.
					Here&#39;s how you could define two states on the alien: <code>normal</code> and
				<code>destroyed</code>:</p>
				<pre><code class="lang-js">alien.states = {
  <span class="hljs-attr">normal</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">destroyed</span>: <span class="hljs-number">1</span>
};
</code></pre>
				<p><code>alien.states.normal</code> now has the value <code>0</code>, and
					<code>alien.states.destroyed</code> now has the value <code>1</code>. That means you could
				display the alien&#39;s <code>normal</code> state like this:</p>
				<pre><code class="lang-js">alien.show(alien.states.normal);
</code></pre>
				<p>And display the alien&#39;s <code>destroyed</code> state like this:</p>
				<pre><code class="lang-js">alien.show(alien.states.destroyed);
</code></pre>
				<p>This makes your code a little more readable because you can tell at a
				glance which sprite state is being displayed.</p>
				<p>(Note: Ga also has a lower-level <code>gotoAndStop</code> method that does
					exactly the
					same thing as <code>show</code>. Although you&#39;re free use <code>gotoAndStop</code> in your
					game code, by convention it&#39;s only used internally by Ga&#39;s rendering
				engine.)</p>
				<p><a id='randomaliens'></a></p>
				<h4 id="generating-random-aliens">Generating random aliens</h4>
				<p>Alien Armada generates aliens at any 1 of 14 randomly chosen positions
					just above the top boundary of the stage. The aliens first appear
					infrequently, but gradually start to
					appear at an ever-increasing rate. This makes the game gradually more
					difficult as it
				progresses. Let&#39;s find out how these two features are implemented.</p>
				<p><a id='timingaliens'></a></p>
				<h5 id="timing-the-aliens">Timing the aliens</h5>
				<p>When the game starts, the first new alien is generated after 100
					frames have elapsed. A variable called <code>alienFrequency</code>, initialized in
					the game&#39;s <code>setup</code> function is used to help track this. it&#39;s
				initialized to 100.</p>
				<pre><code class="lang-js">alienFrequency = <span class="hljs-number">100</span>;
</code></pre>
				<p>Another variable called <code>alienTimer</code> is used to count the number of
					of frames that have elapsed between the previously generated alien,
				and the next one. </p>
				<pre><code class="lang-js">alienTimer = <span class="hljs-number">0</span>;
</code></pre>
				<p><code>alienTimer</code> is updated by 1 each frame in the <code>play</code> function (the game loop).
					When <code>alienTimer</code> reaches the value of <code>alienFrequency</code>, a new alien
					sprite is generated. Here&#39;s the code from the <code>play</code> function that
					does this. (This code omits the actual code that generates the alien
				sprite - we&#39;ll look at that ahead)</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Add one to the alienTimer.</span>
alienTimer++;

<span class="hljs-comment">//Make a new alien if `alienTimer` equals the `alienFrequency`.</span>
<span class="hljs-keyword">if</span>(alienTimer === alienFrequency) {

  <span class="hljs-comment">//... Create the alien: see ahead for the missing code that does this...</span>

  <span class="hljs-comment">//Set the `alienTimer` back to zero.</span>
  alienTimer = <span class="hljs-number">0</span>;

  <span class="hljs-comment">//Reduce `alienFrequency` by one to gradually increase</span>
  <span class="hljs-comment">//the frequency that aliens are created</span>
  <span class="hljs-keyword">if</span>(alienFrequency &gt; <span class="hljs-number">2</span>){  
    alienFrequency--;
  }
}
</code></pre>
				<p>You can see in the code above that <code>alienFrequency</code> is reduced by 1
					after the sprite has been created. That will make the next alien appear 1 frame earlier than the
					previous alien, and which is why the rate of falling aliens slowly
					increases. You can also see that the <code>alienTimer</code> is set back to 0 after the sprite
					has been created so that it can restart counting towards making
				the next new alien. </p>
				<p><a id='randomposition'></a></p>
				<h5 id="the-aliens-random-start-positions">The aliens&#39; random start positions</h5>
				<p>Before we generate any aliens, we need an array to store all the alien
					sprites. An empty array called <code>aliens</code> is initialized in the <code>setup</code>
				function for this purpose.</p>
				<pre><code class="lang-js">aliens = [];
</code></pre>
				<p>Each alien is then created in the <code>play</code> function, inside the same
				<code>if</code> statement we looked at above. This code has a lot of work to do:</p>
				<ul>
					<li>It sets the alien&#39;s image frames and states. </li>
					<li>Its sets the alien&#39;s velocity (<code>vx</code> and <code>vy</code>.) </li>
					<li>It positions the alien at a random horizontal position above the top stage boundary.</li>
					<li>And, finally, it pushes the alien into the <code>aliens</code> array. </li>
				</ul>
				<p>Here&#39;s the full code that does all this:</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Add one to the alienTimer.</span>
alienTimer++;

<span class="hljs-comment">//Make a new alien if `alienTimer` equals the `alienFrequency`.</span>
<span class="hljs-keyword">if</span>(alienTimer === alienFrequency) {

  <span class="hljs-comment">//Create the alien.</span>
  <span class="hljs-comment">//Assign two frames from the texture atlas as the </span>
  <span class="hljs-comment">//alien's two states.</span>
  <span class="hljs-keyword">var</span> alienFrames = [
    <span class="hljs-string">"alien.png"</span>, 
    <span class="hljs-string">"explosion.png"</span>
  ];

  <span class="hljs-comment">//Initialize the alien sprite with the frames</span>
  <span class="hljs-keyword">var</span> alien = g.sprite(alienFrames);

  <span class="hljs-comment">//Define some states on the alien that correspond</span>
  <span class="hljs-comment">//to its two frames.</span>
  alien.states = {
    <span class="hljs-attr">normal</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">destroyed</span>: <span class="hljs-number">1</span>
  };

  <span class="hljs-comment">//Set its y position above the screen boundary.</span>
  alien.y = <span class="hljs-number">0</span> - alien.height;

  <span class="hljs-comment">//Assign the alien a random x position.</span>
  alien.x = g.randomInt(<span class="hljs-number">0</span>, <span class="hljs-number">14</span>) * alien.width;

  <span class="hljs-comment">//Set its speed.</span>
  alien.vy = <span class="hljs-number">1</span>;

  <span class="hljs-comment">//Push the alien into the `aliens` array.</span>
  aliens.push(alien);

  <span class="hljs-comment">//Set the `alienTimer` back to zero.</span>
  alienTimer = <span class="hljs-number">0</span>;

  <span class="hljs-comment">//Reduce `alienFrequency` by one to gradually increase</span>
  <span class="hljs-comment">//the frequency that aliens are created</span>
  <span class="hljs-keyword">if</span>(alienFrequency &gt; <span class="hljs-number">2</span>){  
    alienFrequency--;
  }
}
</code></pre>
				<p>You can see in the code above that th alien&#39;s <code>y</code> position places it
				out of sight just above the stage&#39;s top boundary.</p>
				<pre><code class="lang-js">alien.y = <span class="hljs-number">0</span> - alien.height;
</code></pre>
				<p>It&#39;s <code>x</code> position, however, is random. </p>
				<pre><code class="lang-js">alien.x = g.randomInt(<span class="hljs-number">0</span>, <span class="hljs-number">14</span>) * alien.width;
</code></pre>
				<p>This code places it in one of 15 possible random positions (0 to 14) above the
				top of the stage. Here&#39;s an illustration of these positions:</p>
				<p><img src="/tutorials/screenshots/20.png" alt="The Alien Armada tileset"></p>
				<p>Finally, and very importantly, the code pushes the alien sprite into
				the <code>aliens</code> array.</p>
				<pre><code class="lang-js">aliens.push(alien);
</code></pre>
				<p>All this code starts pumping out aliens at a steadily increasing rate.</p>
				<p><a id='movingaliens'></a></p>
				<h4 id="moving-the-aliens">Moving the aliens</h4>
				<p>How do we make the aliens move? In exactly the same way made the
					bullets move. You&#39;ll notice in the code above that
				each alien is initialized with a <code>vy</code> (vertical velocity) value of 1.</p>
				<pre><code class="lang-js">alien.vy = <span class="hljs-number">1</span>;
</code></pre>
				<p>When this value is applied to the alien&#39;s <code>y</code> position, it will make the alien move down, towards the bottom of the stage,
					at the rate of 1 pixel per frame. All the alien sprites in the game are in
					the <code>aliens</code> array. So to make all of them move you need to loop
					through each sprite in the <code>aliens</code> array each frame and add their
					<code>vy</code> values to their <code>y</code> positions. Some code like this in the <code>play</code>
				function would work:</p>
				<pre><code class="lang-js">aliens.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alien</span>)</span>{
  alien.y += alien.vy;
});
</code></pre>
				<p>However, its easier just to use Ga&#39;s convenient built-in <code>move</code> function. Just
					supply <code>move</code> with the array of sprites that you want to move, like
				this:</p>
				<pre><code class="lang-js">g.move(aliens);
</code></pre>
				<p>This updates the aliens positions with their velocities automatically.</p>
				<p><a id='explodealiens'></a></p>
				<h4 id="making-the-aliens-explode">Making the aliens explode</h4>
				<p>Now that you know how to change the alien&#39;s state, how can you use
					this skill to create the explosion effect? Here&#39;s the simplified code
					from Alien Armada that shows you how to do this. Use <code>hitTestRectangle</code> to
					check for a collision between an alien and bullet. If a collision is detected,
					remove the bullet, show the alien&#39;s <code>destroyed</code> state, and then remove
				the alien after a delay of one second.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span> (g.hitTestRectangle(alien, bullet)) {

  <span class="hljs-comment">//Remove the bullet sprite.</span>
  g.remove(bullet);

  <span class="hljs-comment">//Show the alien's `destroyed` state.</span>
  alien.show(alien.states.destroyed);

  <span class="hljs-comment">//Wait for 1 second (1000 milliseconds) then </span>
  <span class="hljs-comment">//remove the alien sprite.</span>
  g.wait(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    g.remove(alien);
  });
}
</code></pre>
				<p>You can use Ga&#39;s universal <code>remove</code> function to remove any sprite from a
				a game, like this:</p>
				<pre><code class="lang-js">g.remove(anySprite);
</code></pre>
				<p>You can optionally use it to remove more than one sprite at a time by
				listing the sprites to remove in the arguments, like this:</p>
				<pre><code class="lang-js">g.remove(spriteOne, spriteTwo, spriteThree);
</code></pre>
				<p>You can even use it to remove all the sprites in an array of sprites. Just
				supply the sprite array as <code>remove</code>&#39;s only argument:</p>
				<pre><code class="lang-js">g.remove(arrayOfSprites);
</code></pre>
				<p>This will both make the sprites disappear from the screen, and also
				empty them out of the array that they were in.</p>
				<p>Ga also has a convenient method called <code>wait</code> that will run a function
					after any delay (in milliseconds) that you specify. The Alien Armada
					game code uses <code>wait</code> to remove the alien after a one second delay,
				like this:</p>
				<pre><code class="lang-js">g.wait(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  g.remove(alien);
});
</code></pre>
				<p>This allows the alien to display its <code>explosion</code> image state for one
				second before it disappears from the game.</p>
				<p>These are the basic techniques involved in making the aliens explode
					and removing the aliens and bullets from the game when they collide.
					But the actual code used in Alien Armada is a little more complex. That&#39;s
					because the code uses nested <code>filter</code> loops to loop through all the bullets
					and aliens so that they can be checked against each other for
					collisions. The code also plays an explosion sound when a collision
					occurs, and updates the score by 1. Here&#39;s all the code from the
					game&#39;s <code>play</code> function that does this. (If you&#39;re new to JavaScript&#39;s
				<code>filter</code> loops, you can <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">read about how to use them here.</a>)</p>
				<pre><code class="lang-js"><span class="hljs-comment">//Check for a collision between the aliens and the bullets.</span>
<span class="hljs-comment">//Filter through each alien in the `aliens` array.</span>
aliens = aliens.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alien</span>) </span>{

  <span class="hljs-comment">//A variable to help check if the alien is</span>
  <span class="hljs-comment">//alive or dead.</span>
  <span class="hljs-keyword">var</span> alienIsAlive = <span class="hljs-literal">true</span>;

  <span class="hljs-comment">//Filter though all the bullets.</span>
  bullets = bullets.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bullet</span>) </span>{

    <span class="hljs-comment">//Check for a collision between an alien and bullet.</span>
    <span class="hljs-keyword">if</span> (g.hitTestRectangle(alien, bullet)) {

      <span class="hljs-comment">//Remove the bullet sprite.</span>
      g.remove(bullet);

      <span class="hljs-comment">//Show the alien's `destroyed` state.</span>
      alien.show(alien.states.destroyed);

      <span class="hljs-comment">//You could alternatively use the frame number,</span>
      <span class="hljs-comment">//like this:</span>
      <span class="hljs-comment">//alien.show(1);</span>

      <span class="hljs-comment">//Play the explosion sound.</span>
      explosionSound.play();

      <span class="hljs-comment">//Stop the alien from moving.</span>
      alien.vy = <span class="hljs-number">0</span>;

      <span class="hljs-comment">//Set `alienAlive` to false so that it can be</span>
      <span class="hljs-comment">//removed from the array.</span>
      alienIsAlive = <span class="hljs-literal">false</span>;

      <span class="hljs-comment">//Wait for 1 second (1000 milliseconds) then </span>
      <span class="hljs-comment">//remove the alien sprite.</span>
      g.wait(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        g.remove(alien);
      });

      <span class="hljs-comment">//Update the score.</span>
      score += <span class="hljs-number">1</span>;

      <span class="hljs-comment">//Remove the bullet from the `bullets array.</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    } <span class="hljs-keyword">else</span> {

      <span class="hljs-comment">//If there's no collision, keep the bullet in the</span>
      <span class="hljs-comment">//bullets array.</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  });

  <span class="hljs-comment">//Return the value of `alienIsAlive` back to the </span>
  <span class="hljs-comment">//filter loop. If it's `true`, the alien will be</span>
  <span class="hljs-comment">//kept in the `aliens` array. </span>
  <span class="hljs-comment">//If it's `false` it will be removed from the `aliens` array.</span>
  <span class="hljs-keyword">return</span> alienIsAlive;
});
</code></pre>
				<p>As long as the filter loops return <code>true</code>, the current sprite being
					checked will remain in the array. If there&#39;s a collision, however, the
					loops return <code>false</code> and the current alien and bullet will be removed
				from their arrays. </p>
				<p>And that&#39;s how the game&#39;s collision works!</p>
				<p><a id='displayingscore'></a></p>
				<h4 id="displaying-the-score">Displaying the score</h4>
				<p>Another new feature introduced by Alien Armada is a dynamic score
					display. Each time an alien is hit, the score at the top right corner
				of the game screen increases by one. How does this work?</p>
				<p>Alien Armada initializes a <code>text</code> sprite called <code>scoreDisplay</code> in the
				game&#39;s <code>setup</code> function.</p>
				<pre><code class="lang-js">scoreDisplay = g.text(<span class="hljs-string">"0"</span>, <span class="hljs-string">"20px emulogic"</span>, <span class="hljs-string">"#00FF00"</span>, <span class="hljs-number">400</span>, <span class="hljs-number">10</span>);
</code></pre>
				<p>You saw in the previous section
					that 1 is added to the game&#39;s <code>score</code> variable each time an alien is
				hit:</p>
				<pre><code class="lang-js">score += <span class="hljs-number">1</span>;
</code></pre>
				<p>To visibly update the score, all you need to do is set the <code>score</code>
				value as the <code>scoreDisplay</code>&#39;s <code>content</code>, like this:</p>
				<pre><code class="lang-js">scoreDisplay.content = score;
</code></pre>
				<p>And that&#39;s all there is to it!</p>
				<p><a id='endinggame2'></a></p>
				<h4 id="ending-and-resetting-the-game">Ending and resetting the game</h4>
				<p>There are two ways the game can end. Either the player shoots down 60
					aliens, in which case the player wins. Or, one of the aliens has to travel
				beyond the bottom edge of the stage, in which case the aliens win. </p>
				<p>A simple if statement in the <code>play</code> function checks for this. If
					either condition becomes <code>true</code>, the <code>winner</code> is set to either
				&quot;player&quot; or &quot;aliens&quot; and the game&#39;s <code>state</code> is changed to <code>end</code>.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//The player wins if the score matches the value</span>
<span class="hljs-comment">//of `scoreNeededToWin`, which is 60</span>
<span class="hljs-keyword">if</span> (score === scoreNeededToWin) {

  <span class="hljs-comment">//Set the player as the winner.</span>
  winner = <span class="hljs-string">"player"</span>;

  <span class="hljs-comment">//Change the game's state to `end`.</span>
  g.state = end;
}

<span class="hljs-comment">//The aliens win if one of them reaches the bottom of</span>
<span class="hljs-comment">//the stage.</span>
aliens.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alien</span>)</span>{

  <span class="hljs-comment">//Check to see if the `alien`'s `y` position is greater</span>
  <span class="hljs-comment">//than the `stage`'s `height`</span>
  <span class="hljs-keyword">if</span> (alien.y &gt; g.stage.height) { 

    <span class="hljs-comment">//Set the aliens as the winner.</span>
    winner = <span class="hljs-string">"aliens"</span>;

    <span class="hljs-comment">//Change the game's state to `end`.</span>
    g.state = end;
  }
});
</code></pre>
				<p>The <code>end</code> function pauses the game, so that the animation freezes. It
					then displays the <code>gameOverMessage</code>, which will either be &quot;Earth
					Saved!&quot; or &quot;Earth Destroyed!&quot;, depending on the outcome. As an extra
					touch, the music <code>volume</code> is also set to 50%. Then after a
					delay of 3 seconds, a function named <code>reset</code> is called. Here&#39;s the
				complete <code>end</code> function that does all this:</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">//Pause the game loop.</span>
  g.pause();

  <span class="hljs-comment">//Create the game over message text.</span>
  gameOverMessage = g.text(<span class="hljs-string">""</span>, <span class="hljs-string">"20px emulogic"</span>, <span class="hljs-string">"#00FF00"</span>, <span class="hljs-number">90</span>, <span class="hljs-number">120</span>);

  <span class="hljs-comment">//Reduce the music volume by half.</span>
  <span class="hljs-comment">//1 is full volume, 0 is no volume, and 0.5 is half volume.</span>
  music.volume = <span class="hljs-number">0.5</span>;

  <span class="hljs-comment">//Display "Earth Saved!" if the player wins.</span>
  <span class="hljs-keyword">if</span> (winner === <span class="hljs-string">"player"</span>) {
    gameOverMessage.content = <span class="hljs-string">"Earth Saved!"</span>;
    gameOverMessage.x = <span class="hljs-number">120</span>;
  }

  <span class="hljs-comment">//Display "Earth Destroyed!" if the aliens win.</span>
  <span class="hljs-keyword">if</span> (winner === <span class="hljs-string">"aliens"</span>) {
    gameOverMessage.content = <span class="hljs-string">"Earth Destroyed!"</span>;  
  }

  <span class="hljs-comment">//Wait for 3 seconds then run the `reset` function.</span>
  g.wait(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    reset(); 
  });
}
</code></pre>
				<p>The <code>reset</code> function resets all of the game variables back to their
					starting values. It also turns the music volume back up to 1. It uses
					the <code>remove</code> function to remove any remaining sprites from the
					<code>aliens</code> and <code>bullets</code> arrays, so that those arrays can be
					re-populated when the game starts again. <code>remove</code> is also used to
					remove the <code>gameOverMessage</code>, and the <code>cannon</code> sprite is re-centered
					at the bottom of the stage. Finally, the game <code>state</code> is set back to
					<code>play</code>, and the game loop is un-paused by calling Ga&#39;s <code>resume</code>
				method.</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">//Reset the game variables.</span>
  score = <span class="hljs-number">0</span>;
  alienFrequency = <span class="hljs-number">100</span>;
  alienTimer = <span class="hljs-number">0</span>;
  winner = <span class="hljs-string">""</span>;

  <span class="hljs-comment">//Set the music back to full volume.</span>
  music.volume = <span class="hljs-number">1</span>;

  <span class="hljs-comment">//Remove any remaining alien and bullet sprites.</span>
  <span class="hljs-comment">//The universal `remove` method will loop through</span>
  <span class="hljs-comment">//all the sprites in an array of sprites, removed them</span>
  <span class="hljs-comment">//from their parent container, and splice them out of the array.</span>
  g.remove(aliens);
  g.remove(bullets);

  <span class="hljs-comment">//You can also use the universal `remove` function to remove.</span>
  <span class="hljs-comment">//a single sprite.</span>
  g.remove(gameOverMessage);

  <span class="hljs-comment">//Re-center the cannon.</span>
  g.stage.putBottom(cannon, <span class="hljs-number">0</span>, <span class="hljs-number">-40</span>);

  <span class="hljs-comment">//Change the game state back to `play`.</span>
  g.state = play;
  g.resume();
}
</code></pre>
				<p>And this is all the code needed to start the game again. You can play
					Alien Armada as many times as you like and it will reset and restart
				itself like this endlessly.</p>
				<p><a id='flappyfairy'></a></p>
				<h3 id="flappy-fairy-">Flappy Fairy!</h3>
				<p>Flappy Fairy is a homage to one of the infamous games ever made: <a href="http://en.wikipedia.org/wiki/Flappy_Bird">Flappy
					Bird</a>. Click the
				image link below to play the game:</p>
				<p><a href="https://cdn.rawgit.com/kittykatattack/ga/master/tutorials/05_flappyFairy.html"><img src="/tutorials/screenshots/21.png" alt="FlappyFairy"></a></p>
				<p>Click the &quot;Go&quot; button, and game will launch in fullscreen mode. Tap
					anywhere on the screen to make the fairy fly, and help her navigate
					through the gaps in 15 pillars to reach the finish. A trail of multicolored
					fairy dust follows the fairy as she flies through the maze.
					If she hits one of the green blocks she explodes in a shower of dust.
					But if she manages to navigate through the increasingly narrowing gaps between
				all 15 pillars, she reaches a big floating Finish sign. </p>
				<p><img src="/tutorials/screenshots/22.png" alt="Flappy Fairy gameplay"></p>
				<p>If you can make a game like Flappy Fairy, you can make almost any
					other kind of 2D action game. In addition to using the all techniques you&#39;ve
				already learnt, Flappy Fairy introduces some exciting new ones:</p>
				<ul>
					<li>Launching a game in fullscreen mode.</li>
					<li>Make a click-able button. </li>
					<li>Create an animated sprite.</li>
					<li>Use a <code>tilingSprite</code> to make a scrolling background.</li>
					<li>Use particle effects.</li>
				</ul>
				<p>You&#39;ll find the fully commented Flappy Fairy source code in the
					<code>tutorials</code> folder. Make sure to take a look at it so that you can see
					all of this code in its proper context. Its general structure is identical
					to the other games in this tutorial, with the addition of these new techniques. Let&#39;s
				find out how they were implemented.</p>
				<p><a id='launchagameinfullscreenmode'></a></p>
				<h4 id="launch-a-game-in-fullscreen-mode">Launch a game in fullscreen mode</h4>
				<p>When you start Flappy Fairy by clicking the &quot;Go&quot; button,
					the game expands to fill your entire screen. This is done with
				the help of a built-in method called <code>enableFullscreen</code>.</p>
				<pre><code class="lang-js">g.enableFullsreen(listOfAsciiExitKeyCodes);
</code></pre>
				<p>It&#39;s one optional argument is a list of Ascii key codes. They refer to keyboard
					keys that could be used to exit fullscreen mode. For example, if you
					want fullscreen mode to exit if a user presses upper-case &quot;X&quot; or
					lower-case &quot;x&quot;, list their Ascii code values in the arguments like
				this:</p>
				<pre><code class="lang-js">g.enableFullscreen(<span class="hljs-number">88</span>, <span class="hljs-number">120</span>);
</code></pre>
				<p>(88 is &quot;X&quot; and 120 is &quot;x&quot;.) You can list as many key codes as you
				like. If you leave these arguments out, the default <code>esc</code> key will do the trick.</p>
				<p><code>enableFullscreen</code>&#39;s behaviour is very simple: it just launches fullscreen mode
					whenever the user releases the pointer (mouse or touch) over the
				canvas. Add it just below your game&#39;s <code>start</code> method, like this:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> g = ga(
  <span class="hljs-number">910</span>, <span class="hljs-number">512</span>, setupTitleScreen,
  [
    <span class="hljs-string">"images/flappyFairy/flappyFairy.json"</span>
  ]
);

g.start();
g.enableFullscreen(<span class="hljs-number">88</span>, <span class="hljs-number">120</span>); <span class="hljs-comment">//&lt;- Add it here</span>
</code></pre>
				<p>It&#39;s a quick and easy way to make any games run fullscreen.</p>
				<p>(Note: Fullscreen mode is different than <code>scaleToWindow</code> because it
					completely takes over the user&#39;s screen. And I mean completely: the
					browser disappears and the only thing on the screen is your game. That&#39;s cool, but many users
					will find it disorienting and become stressed or panicked if they
					can&#39;t figure out how to exit your game. So you do decide to run your game in fullscreen
					mode, be confident that users will know how to exit it. Or, play it
					safe and just use <code>scaleToWindow</code>, which still looks great but doesn&#39;t
				take over the entire browser UI.)</p>
				<p><a id='makeabutton'></a></p>
				<h4 id="make-a-button">Make a button</h4>
				<p>The game starts when you press the &quot;Go&quot; button. The &quot;Go&quot; button is a special sprite
					called a <code>button</code>. <code>button</code> sprites have 3 image frame states: up, over and
				down. You can create a <code>button</code> with three states like this:</p>
				<pre><code class="lang-js">goButton = g.button([
  <span class="hljs-string">"up.png"</span>,
  <span class="hljs-string">"over.png"</span>,
  <span class="hljs-string">"down.png"</span>
]);
</code></pre>
				<p><code>up.png</code> is an image that shows what the button should look like when the it&#39;s not
					interacting with the pointer. <code>over.png</code> shows what the button looks
					like when the pointer is over it, and <code>down.png</code> is the image that is
				displayed when the pointer presses down on the button.</p>
				<p><img src="/tutorials/screenshots/23.png" alt="Button states"></p>
				<p>(The <code>down.png</code> image is offset slightly down and to the right, so it
					looks like its being pressed down.) You can assign any images you like
					to these states, and the <code>button</code>
					will display them automatically based on how the pointer is
				interacting with it. </p>
				<p>(Note: If your game is touch-only, you might have only
					two button states: up and down. In that case, just assign two image frames,
				and Ga will assume they refer to the up and down states.)</p>
				<p>Buttons have special methods that you can define: <code>press</code>,
					<code>release</code>,<code>over</code>, <code>out</code> and <code>tap</code>. You can assign any code you like to
					these methods. For example, here&#39;s how you could change the game&#39;s
				state when the user releases the <code>playButton</code>:</p>
				<pre><code class="lang-js">goButton.release = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  g.state = setupGame;
};
</code></pre>
				<p>Buttons also have a Boolean (true/false) property called <code>enabled</code>
					that you
					can set to <code>false</code> if you want to disable the button. (Set <code>enabled</code>
					to <code>true</code> to re-enable it.) You can also use the button&#39;s <code>state</code>
					property to find out if the button state is currently <code>&quot;up&quot;</code>, <code>&quot;over&quot;</code>
				or <code>&quot;down&quot;</code>. (These state values are strings.)</p>
				<p>Important! You can give <strong>any</strong> sprite the qualities of button just by
				setting its <code>interactive</code> property to <code>true</code>, like this:</p>
				<pre><code class="lang-js">anySprite.interactive = <span class="hljs-literal">true</span>;
</code></pre>
				<p>This will give the sprite <code>press</code>, <code>release</code>, <code>over</code>, <code>out</code> and <code>tap</code>
					methods, and the same <code>state</code> property as ordinary buttons. This means
					that you can make any sprite click-able, which is really useful for a
				wide variety of interactive games.</p>
				<p>You can also make the <code>stage</code> object interactive, which turns the whole
				game screen into an interactive button:</p>
				<pre><code class="lang-js">g.stage.interactive = <span class="hljs-literal">true</span>;
</code></pre>
				<p>For more detail on how to use buttons, see the <code>buttons.html</code> file
				in the <code>examples</code> folder.</p>
				<p><a id='animatingsprites'></a></p>
				<h4 id="animating-sprites">Animating sprites</h4>
				<p>A neat feature of Flappy Fairy is that the fairy character flaps her wings
					when she&#39;s flying up. This animation was created by rapidly displaying 3
					simple images in a continuous loop. Each image displays a slightly different
				frame of the animation, as shown below:</p>
				<p><img src="/tutorials/screenshots/24.png" alt="Animation frames"></p>
				<p>These three images are just three ordinary frames in the game&#39;s texture atlas, called
					<code>0.png</code>, <code>1.png</code> and <code>2.png</code>.
					But how can you turn a sequence of frames like this into a sprite
				animation?</p>
				<p>First, create an array that defines the frames of the animation, like
				this:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> fairyFrames = [
  <span class="hljs-string">"0.png"</span>, 
  <span class="hljs-string">"1.png"</span>, 
  <span class="hljs-string">"2.png"</span>
];
</code></pre>
				<p>Then create a sprite using those frames, like this:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> fairy = g.sprite(fairyFrames);
</code></pre>
				<p>Or, if you prefer, you can combine this into one step:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> fairy = g.sprite([
  <span class="hljs-string">"0.png"</span>, 
  <span class="hljs-string">"1.png"</span>, 
  <span class="hljs-string">"2.png"</span>
]);
</code></pre>
				<p>Any sprite with more than one image frame automatically becomes an
					animated sprite. If you want the animation frames to start playing,
				just call the sprite&#39;s <code>play</code> method:</p>
				<pre><code class="lang-js">fairy.play();
</code></pre>
				<p>The frames will automatically play in a continuous loop. If you don&#39;t want them
				to loop, set <code>loop</code> to <code>false</code>.</p>
				<pre><code class="lang-js">fairy.loop = <span class="hljs-literal">false</span>;
</code></pre>
				<p>Use the <code>stop</code> method to stop an animation:</p>
				<pre><code class="lang-js">fairy.stop();
</code></pre>
				<p>If you want to know whether or not a sprite&#39;s animation is currently
				playing, use the Boolean (true/false) <code>playing</code> property to find out.</p>
				<p>How quickly or slowly do you want the animation to play? You can set
				the animation&#39;s frames-per-second (<code>fps</code>) like this:</p>
				<pre><code class="lang-js">fairy.fps = <span class="hljs-number">24</span>;
</code></pre>
				<p>A sprite animation&#39;s frame rate is independent of the game&#39;s frame
					rate. That gives you a lot of flexibility to fine-tune sprite
				animations.</p>
				<p>What if you don&#39;t want to use all the sprite&#39;s image frames in the
					animation, only some of them? You can use the <code>playSequence</code> method.
					For example, imagine that you have a sprite with 30 frames, but you
					only want to play frames 10 to 15 as part of the animation. Use the
					<code>playSequence</code> method and supply it with an array containing two
				numbers: the first and last frames of the sequence you want to play.</p>
				<pre><code class="lang-js">animatedSprite.playSequence([<span class="hljs-number">10</span>, <span class="hljs-number">15</span>]);
</code></pre>
				<p>Now only the frames between 10 to 15 will play as part of the animation. To make
					this more readable, you can define the sequence as an array that
					describes what those animated frames actually do. For example, perhaps
					they define a character&#39;s walk cycle. You could create an array called
				<code>walkCycle</code> that defines those frames:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> walkCycle = [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>];
</code></pre>
				<p>Then use that array with <code>playSequence</code>, like this:</p>
				<pre><code class="lang-js">animatedSprite.playSequence(walkCycle);
</code></pre>
				<p>That&#39;s a bit more code to write, but much more readable!</p>
				<p>For more details on Ga&#39;s sprite animation system and what you can do
					with it, see the <code>keyframeAnimation.html</code>,
				<code>textureAtlasAnimation.html</code> and  <code>animationStates.html</code> file in the <code>examples</code> folder.</p>
				<p><a id='makingthefairyfly'></a></p>
				<h4 id="making-the-fairy-fly">Making the fairy fly</h4>
				<p>Now that you know how to animate a sprite, how is Flappy Fairy&#39;s
				flying animation triggered when you tap on the game screen?</p>
				<p>A value of <code>0.05</code>, which represents gravity, is subtracted from the
					fairy&#39;s <code>y</code> position each frame in the <code>play</code> function. This is the
				gravity effect that pulls the fairy to the bottom of the screen. </p>
				<pre><code class="lang-js">fairy.vy += <span class="hljs-number">-0.05</span>;
fairy.y -= fairy.vy;
</code></pre>
				<p>But when you tap the screen, the fairy flies up. This is thanks to
					Ga&#39;s built-in <code>pointer</code> object. It has a <code>tap</code> method which you can define to
					perform any action you like. In Flappy Fairy, the <code>tap</code> method increases the fairy&#39;s vertical
				velocity, <code>vy</code>, by 1.5 pixels each time you tap.</p>
				<pre><code class="lang-js">g.pointer.tap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  fairy.vy += <span class="hljs-number">1.5</span>;
};
</code></pre>
				<p>Ga&#39;s built-in <code>pointer</code> object also has <code>press</code> and <code>release</code> methods
					that you can define in the same way. It also has Boolean (true/false)
					<code>isUp</code>, <code>isDown</code> and <code>tapped</code> properties that you can use to find the
				pointer&#39;s state, if you need to.</p>
				<p>But you&#39;ll notice that the fairy only flaps her wings when she&#39;s
					starting to fly up, and stops flapping when she looses momentum and
					starts going down. To make this work, you need to know whether the fairy is
					currently on the way up, or on the way down, based on a change in the
					fairy&#39;s vertical velocity (vy) value. The game implements a well-worn
					old trick to help figure this out. The <code>play</code> function captures the
					fairy&#39;s velocity for this current frame in a new value called <code>oldVy</code>. But
				it does this <em>only after the fairy&#39;s position has changed</em>. </p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span>{

  <span class="hljs-comment">//...</span>
  <span class="hljs-comment">//... all of the code that moves the fairy comes first...</span>
  <span class="hljs-comment">//...</span>

  <span class="hljs-comment">//Then, after the fairy's position has been changed, capture</span>
  <span class="hljs-comment">//her velocity for this current frame</span>
  fairy.oldVy = fairy.vy;
}
</code></pre>
				<p>This means that when the next game frame swings around, <code>oldVy</code> will still be storing the
					fairy&#39;s velocity value from the <em>previous frame</em>. And that means you
					can use that value to figure out the change in the fairy&#39;s velocity from the
					previous frame to the current frame. If she&#39;s starting to go up (if <code>vy</code> is
				greater than <code>oldVy</code>), play the fairy&#39;s animation: </p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span> (fairy.vy &gt; fairy.oldVy) {
  <span class="hljs-keyword">if</span>(!fairy.playing) {
    fairy.play();
  }
}
</code></pre>
				<p>If she&#39;s starting to go down, stop the animation and just show the
				fairy&#39;s first frame.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span> (fairy.vy &lt; <span class="hljs-number">0</span> &amp;&amp; fairy.oldVy &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">if</span> (fairy.playing) fairy.stop();
  fairy.show(<span class="hljs-number">0</span>);
}
</code></pre>
				<p>And that&#39;s how the fairy flies!</p>
				<p><a id='makeascrollingbackground'></a></p>
				<h4 id="make-a-scrolling-background">Make a scrolling background</h4>
				<p>A fun new feature of Flappy Fairy is that it has an infinitely scrolling
				background of clouds moving from right to left.</p>
				<p><img src="/tutorials/screenshots/25.png" alt="Scrolling background"></p>
				<p>The background moves at a slower rate than the green pillars, and that
					creates the illusion that the clouds are further away. (This is a
				shallow, pseudo 3D effect called <strong>paralax scrolling</strong>.) </p>
				<p>The background is just a single image.</p>
				<p><img src="/tutorials/screenshots/26.png" alt="Scrolling background"></p>
				<p>The image has been designed so that the clouds <strong>tile seamlessly</strong>:
					the clouds on the top and left match up with the clouds on the right
					and bottom. That means you can connect multiple instances of the same
					image and they will appear to create a single, unbroken continuous
				image. (<a href="opengameart.org/content/cartoony-sky">Image from OpenGameArt.</a>) </p>
				<p>Because this is really useful for games, Ga has a sprite type
					called a <code>tilingSprite</code> that&#39;s designed just for such infinite
				scrolling effects. Here&#39;s how to create a <code>tilingSprite</code>: </p>
				<pre><code class="lang-js">sky = g.tilingSprite(
  g.canvas.width,        <span class="hljs-comment">//The width</span>
  g.canvas.height,       <span class="hljs-comment">//The height</span>
  <span class="hljs-string">"sky.png"</span>              <span class="hljs-comment">//The image to use</span>
);
</code></pre>
				<p>The first two arguments are the sprite&#39;s width and height, and the
				last is the image your want to use. </p>
				<p>Tiling sprites have the
					same properties as normal sprites, with the addition of two new
					properties:
					<code>tileX</code> and <code>tileY</code>. Those two properties let you set the image offset from the
					sprite&#39;s top left corner. If you want to make a tiling sprite scroll
					continuously, just increase its <code>tileX</code> value by some small amount
				each frame in the game loop, like this:</p>
				<pre><code class="lang-js">sky.tileX -= <span class="hljs-number">1</span>;
</code></pre>
				<p>And that&#39;s all you need to do to make an infinitely scrolling
				background.</p>
				<p><a id='particleeffects'></a></p>
				<p>####Particle effects</p>
				<p>How do you create effects like fire, smoke, magic, and explosions?
					You make lots of tiny sprites; dozens, hundreds or thousands of them.
					Then apply some physical or gravitational constraints to those sprites
					so that they behave like the element youre trying to simulate. You
					also need to give them some rules about how they should appear and
					disappear, and what kinds of patterns they should form. These tiny
					sprites are called particles. You can use them to make a wide range
				of special effects for games.</p>
				<p>Ga has a versatile built-in method called <code>particleEffect</code> that can
					create most kinds of particle effects you&#39;ll need for games. Here&#39;s
				the format for using it:</p>
				<pre><code class="lang-js">particleEffect(
  pointer.x,                                     <span class="hljs-comment">//The particles starting x position</span>
  pointer.y,                                     <span class="hljs-comment">//The particles starting y position</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> sprite(<span class="hljs-string">"images/star.png"</span>)},  <span class="hljs-comment">//Particle function</span>
  <span class="hljs-number">20</span>,                                            <span class="hljs-comment">//Number of particles</span>
  <span class="hljs-number">0.1</span>,                                           <span class="hljs-comment">//Gravity</span>
  <span class="hljs-literal">true</span>,                                          <span class="hljs-comment">//Random spacing</span>
  <span class="hljs-number">0</span>, <span class="hljs-number">6.28</span>,                                       <span class="hljs-comment">//Min/max angle</span>
  <span class="hljs-number">12</span>, <span class="hljs-number">24</span>,                                        <span class="hljs-comment">//Min/max size</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,                                          <span class="hljs-comment">//Min/max speed</span>
  <span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>,                                   <span class="hljs-comment">//Min/max scale speed</span>
  <span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>,                                   <span class="hljs-comment">//Min/max alpha speed</span>
  <span class="hljs-number">0.05</span>, <span class="hljs-number">0.1</span>                                      <span class="hljs-comment">//Min/max rotation speed</span>
);
</code></pre>
				<p>You can see that most of the arguments describe a range between the
					minimum and maximum values that should be used to change the sprites
					speed, rotation, scale, or alpha. You can also assign the number of
					particles that should be created, and add optional gravity.
					You can make particles using any sprites by customizing the third argument.
					Just supply a function that returns the kind of sprite you want to use
				for each particle:</p>
				<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">return</span> sprite(<span class="hljs-string">"images/star.png"</span>)},
</code></pre>
				<p>If you supply a sprite that has multiple frames, the <code>particleEffect</code>
					function will automatically choose a random frame for each particle.
					The minimum and maximum angle values are important for defining the
					circular spread of particles as they radiate out from the origin point.
					For a completely circular explosion effect, use a minimum angle of 0 and
				a maximum angle of 6.28.</p>
				<pre><code class="lang-js"><span class="hljs-number">0</span>, <span class="hljs-number">6.28</span>,
</code></pre>
				<p>(These values are radians; the equivalent in degrees is 0 and 360.)
					0 starts at the 3 oclock position, pointing directly to the right. 3.14
					is the 9 oclock position, and 6.28 takes you around back to 0 again.
					If you want to constrain the particle range to a narrower angle, just
					supply the minimum and maximum values that describe that range. Here are
					values you could use to constrain the angle to a pizza-slice with the
				crust pointing left.</p>
				<pre><code class="lang-js"><span class="hljs-number">2.4</span>, <span class="hljs-number">3.6</span>,
</code></pre>
				<p>You could use a constrained angle range like this to create a particle
					stream, like those used to create a fountain or rocket engine flames.
					(Youll see exactly how to do this ahead.) The random spacing value
					(the sixth argument) determines whether the particles should be spaced
					evenly (<code>false</code>) or randomly (<code>true</code>) within this range.
					By carefully choosing the sprite for the particle and finely adjusting
					each parameter, you can use this all-purpose <code>particleEffect</code> method
					to simulate everything from liquid to fire. In Flappy Fairy, it&#39;s used
				to create fairy dust.</p>
				<p><a id='thefairydustexplosions'></a></p>
				<p>#####The fairy dust explosions</p>
				<p>When Flappy Fairy hits a block, she disappears in a puff of dust. </p>
				<p><img src="/tutorials/screenshots/27.png" alt="Fairy dust explosion"></p>
				<p>How does that effect work?</p>
				<p>Before we can create the explosion effect, we have to define an array
					that lists the images we want to use for each particle.
					As you learned above, the <code>particleEffect</code> method will randomly
					display a frame on a sprite, if that sprite contains multiple frames.
					To make this work, first define an array of texture atlas frames that
				you want to use for the fairy&#39;s dust explosion:</p>
				<pre><code class="lang-js">dustFrames = [
  <span class="hljs-string">"pink.png"</span>,
  <span class="hljs-string">"yellow.png"</span>,
  <span class="hljs-string">"green.png"</span>,
  <span class="hljs-string">"violet.png"</span>
];
</code></pre>
				<p>The explosion happens when the fairy hits one of the green blocks.
					The game loop does this with the help of the <code>hitTestRectangle</code>
					method. The code loops through the <code>blocks.children</code> array and tests for
					a collision between each green block and the fairy. If <code>hitTestRectangle</code>
					returns <code>true</code>, the loop quits and a collision object called
				<code>fairyVsBlock</code> becomes <code>true</code>.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> fairyVsBlock = blocks.children.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">block</span>)</span>{
  <span class="hljs-keyword">return</span> g.hitTestRectangle(fairy, block, <span class="hljs-literal">true</span>);  
});
</code></pre>
				<p><code>hitTestRectangle</code>s third argument needs to be <code>true</code> so that the collision
					detection is done using the sprites global coordinates (<code>gx</code> and <code>gy</code>).
					Thats because the fairy is a child of the <code>stage</code>, but each block is a child
					of the <code>blocks</code> group. That means they dont share the same local coordinate space.
					Using the blocks sprites&#39; global coordinates forces <code>hitTestRectangle</code>
				to use their positions relative to the canvas. </p>
				<p>If <code>fairyVsBlock</code> is <code>true</code>, and the fairy is currently visible, the
					collision code runs. It makes the fairy invisible, creates the particle
				explosion, and calls the games <code>reset</code> function after a delay of 3 seconds.</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span> (fairyVsBlock &amp;&amp; fairy.visible) {

  <span class="hljs-comment">//Make the fairy invisible</span>
  fairy.visible = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">//Create a fairy dust explosion</span>
  g.particleEffect(
    fairy.centerX, fairy.centerY, <span class="hljs-comment">//x and y position</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                  <span class="hljs-comment">//Particle sprite</span>
      <span class="hljs-keyword">return</span> g.sprite(dustFrames);
    },     
    <span class="hljs-number">20</span>,                           <span class="hljs-comment">//Number of particles</span>
    <span class="hljs-number">0</span>,                            <span class="hljs-comment">//Gravity</span>
    <span class="hljs-literal">false</span>,                        <span class="hljs-comment">//Random spacing</span>
    <span class="hljs-number">0</span>, <span class="hljs-number">6.28</span>,                      <span class="hljs-comment">//Min/max angle</span>
    <span class="hljs-number">16</span>, <span class="hljs-number">32</span>,                       <span class="hljs-comment">//Min/max size</span>
    <span class="hljs-number">1</span>, <span class="hljs-number">3</span>                          <span class="hljs-comment">//Min/max speed</span>
  );

  <span class="hljs-comment">//Stop the dust emitter that's trailing the fairy.</span>
  <span class="hljs-comment">//(More about this ahead!)</span>
  dust.stop();

  <span class="hljs-comment">//Wait 3 seconds and then reset the game</span>
  g.wait(<span class="hljs-number">3000</span>, reset);
}
</code></pre>
				<p><a id='useaparticleemitter'></a></p>
				<p>#####Use a particle emitter</p>
				<p>A particle emitter is just a simple timer that creates particles at
					fixed intervals. That means instead of just calling the
					<code>particleEffect</code> function once, the emitter calls it periodically.
					Ga has a built-in <code>emitter</code> method that let&#39;s you do this easily.
				Heres how to use it:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">var</span> particleStream = g.emitter(
  <span class="hljs-number">100</span>,                                     <span class="hljs-comment">//The interval</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> g.particleEffect(     <span class="hljs-comment">//The `particleEffect` function</span>
    <span class="hljs-comment">//Assign particle parameters...</span>
  )
);
</code></pre>
				<p>The <code>emitter</code> method just wraps around the <code>particleEffect</code> method.
					Its first argument is a number, in milliseconds, that determines how
					frequently the particles should be created. The second argument is
					the <code>particleEffect</code> method, which you can customize however you like.
					The <code>emitter</code> method returns an object with <code>play</code> and <code>stop</code> methods
					that you can use to control the particle stream. You can use them
					just like the <code>play</code> and <code>stop</code> methods you use to control a sprites
				animation.</p>
				<pre><code class="lang-js">particleStream.play();
particleStream.stop();
</code></pre>
				<p>The emitter object also has a <code>playing</code> property that will be either
					<code>true</code> or <code>false</code> depending on the emitters current state. (See the
					<code>particleEmitter.html</code> file in the <code>examples</code> folder for more details
				on how to create and use a particle emitter.)</p>
				<p>A particle emitter is used in Flappy Fairy to make the fairy emit a
					stream of multicolored particles while shes flapping her wings. The
					particles are constrained to an angle between 2.4 and 3.6 radians, so
				theyre emitted in a cone-shaped wedge to the left of the fairy. </p>
				<p><img src="/tutorials/screenshots/28.png" alt="Emitting fairy dust"></p>
				<p>The particle stream randomly emits pink, yellow, green, or violet
				particles, each of which is a separate frame on the texture atlas.</p>
				<p>Here&#39;s the code that creates this effect: </p>
				<pre><code class="lang-js">dust = g.emitter(
  <span class="hljs-number">300</span>,                                   <span class="hljs-comment">//The interval</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> g.particleEffect(             <span class="hljs-comment">//The function</span>
      fairy.x + <span class="hljs-number">8</span>,                       <span class="hljs-comment">//x position</span>
      fairy.y + fairy.halfHeight + <span class="hljs-number">8</span>,    <span class="hljs-comment">//y position</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{                       <span class="hljs-comment">//Particle sprite</span>
        <span class="hljs-keyword">return</span> g.sprite(dustFrames)
      },          
      <span class="hljs-number">3</span>,                                 <span class="hljs-comment">//Number of particles</span>
      <span class="hljs-number">0</span>,                                 <span class="hljs-comment">//Gravity</span>
      <span class="hljs-literal">true</span>,                              <span class="hljs-comment">//Random spacing</span>
      <span class="hljs-number">2.4</span>, <span class="hljs-number">3.6</span>,                          <span class="hljs-comment">//Min/max angle</span>
      <span class="hljs-number">12</span>, <span class="hljs-number">18</span>,                            <span class="hljs-comment">//Min/max size</span>
      <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,                              <span class="hljs-comment">//Min/max speed</span>
      <span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>,                       <span class="hljs-comment">//Min/max scale speed</span>
      <span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>,                       <span class="hljs-comment">//Min/max alpha speed</span>
      <span class="hljs-number">0.05</span>, <span class="hljs-number">0.1</span>                          <span class="hljs-comment">//Min/max rotation speed</span>
    );
  }
);
</code></pre>
				<p>You can now control the <code>dust</code> emitter with <code>play</code> and <code>stop</code> methods.</p>
				<p><a id='creatingandmovingthepillars'></a></p>
				<p>####Creating and moving the pillars</p>
				<p>You now know how Flappy Fairy implements some of Ga&#39;s special features
					for some fun and useful effects. But, if you&#39;re new to game
					programming, you might also be wondering how the world that Flappy Fairy flies
					through was created. Let&#39;s take a quick look at the code that creates
					and moves the green pillars that the fairy has to navigate to reach
				the Finish sign.</p>
				<p>There are fifteen green pillars in the game. Every five pillars, the
					gap between the top and bottom sections becomes narrower. The first five
					pillars have a gap of four blocks, the next five have a gap of three blocks
					and the last five have a gap of two blocks. This makes the game increasingly
					difficult as Flappy Fairy flies further. The exact position of the gap is
					random for each pillar, and different every time game is played. Each pillar
					is spaced by 384 pixels, and here&#39;s how they would look like if
				they were right next to each other.</p>
				<p><img src="/tutorials/screenshots/29.png" alt="The green pillars"></p>
				<p>You can see how the gap gradually narrows from four spaces on the left
				down to two on the right. </p>
				<p>All the blocks that make up the pillars are in a <code>group</code> called
				<code>blocks</code>.</p>
				<pre><code class="lang-js">blocks = g.group();
</code></pre>
				<p>A nested for loop creates each block and adds it to the blocks container.
					The outer loop runs 15 times; once to create each pillar. The inner loop
					runs eight times; once for each block in the pillar. The blocks are only
					added if theyre not occupying the range thats been randomly chosen for
				the gap. Every fifth time the outer loop runs, the size of the gap narrows by one.</p>
				<pre><code class="lang-js"><span class="hljs-comment">//What should the initial size of the gap be between the pillars?</span>
<span class="hljs-keyword">var</span> gapSize = <span class="hljs-number">4</span>;

<span class="hljs-comment">//How many pillars?</span>
<span class="hljs-keyword">var</span> numberOfPillars = <span class="hljs-number">15</span>;

<span class="hljs-comment">//Loop 15 times to make 15 pillars</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numberOfPillars; i++) {

  <span class="hljs-comment">//Randomly place the gap somewhere inside the pillar</span>
  <span class="hljs-keyword">var</span> startGapNumber = g.randomInt(<span class="hljs-number">0</span>, <span class="hljs-number">8</span> - gapSize); 

  <span class="hljs-comment">//Reduce the `gapSize` by one after every fifth pillar. This is</span>
  <span class="hljs-comment">//what makes gaps gradually become narrower</span>
  <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) gapSize -= <span class="hljs-number">1</span>; 

  <span class="hljs-comment">//Create a block if it's not within the range of numbers</span>
  <span class="hljs-comment">//occupied by the gap</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) {
    <span class="hljs-keyword">if</span> (j &lt; startGapNumber || j &gt; startGapNumber + gapSize - <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">var</span> block = g.sprite(<span class="hljs-string">"greenBlock.png"</span>);
      blocks.addChild(block);

      <span class="hljs-comment">//Space each pillar 384 pixels apart. The first pillar will be</span>
      <span class="hljs-comment">//placed at an x position of 512</span>
      block.x = (i * <span class="hljs-number">384</span>) + <span class="hljs-number">512</span>;
      block.y = j * <span class="hljs-number">64</span>;
    }
  }

  <span class="hljs-comment">//After the pillars have been created, add the finish image</span>
  <span class="hljs-comment">//right at the end</span>
  <span class="hljs-keyword">if</span> (i === numberOfPillars - <span class="hljs-number">1</span>) {
    finish = g.sprite(<span class="hljs-string">"finish.png"</span>);
    blocks.addChild(finish);
    finish.x = (i * <span class="hljs-number">384</span>) + <span class="hljs-number">896</span>;
    finish.y = <span class="hljs-number">192</span>;
  }
}
</code></pre>
				<p>The last part of the code adds the big <code>finish</code> sprite to the world, which
				Flappy Fairy will see if she manages to make it through to the end.</p>
				<p>The game loop moves the group of blocks by 2 pixels to the right each
				frame, but only while the finish sprite is off-screen:</p>
				<pre><code class="lang-js"><span class="hljs-keyword">if</span> (finish.gx &gt; <span class="hljs-number">256</span>) {
  blocks.x -= <span class="hljs-number">2</span>;
}
</code></pre>
				<p>When the <code>finish</code> sprite scrolls into the center of the canvas, the
					<code>blocks</code> container will stop moving. Notice that the code uses the
					<code>finish</code> sprites global x position (<code>gx</code>) to test whether its inside
					the area of the canvas. Because global coordinates are relative to
					the canvas, not the parent container, theyre really useful for
					just these kinds of situations where you want to want to find a
				nested sprites position on the canvas.</p>
				<p>Make sure you check out the complete Flappy Fairy source code in the
				<code>examples</code> folder so that you can see all this code in its proper context.</p>
				<p><a id='aguidetotheexamples'></a></p>
				<p>#Coming soon: A guide to the examples</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ga_d_.html">"ga.d"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ga_plugins_d_.html">"ga.plugins.d"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>